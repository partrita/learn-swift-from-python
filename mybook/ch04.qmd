# 데이터 타입

### 기본 타입

| Swift 타입 | 파이썬 대응 | 설명                       | 예시 (Swift)                   |
|------------|-------------|----------------------------|--------------------------------|
| `Int`      | `int`       | 정수                       | `let age: Int = 25`            |
| `Double`   | `float`     | 64비트 부동 소수점 숫자    | `let pi: Double = 3.14159`     |
| `Float`    | `float`     | 32비트 부동 소수점 숫자    | `let price: Float = 19.99`     |
| `Bool`     | `bool`      | `true` 또는 `false`        | `let isValid: Bool = true`     |
| `String`   | `str`       | 문자열                     | `let greeting: String = "Hello"`|
| `Character`| (단일 문자 str) | 단일 문자                | `let initial: Character = "J"` |


**문자열 보간법:**
파이썬의 f-string과 유사합니다.

**파이썬:**
```python
name = "World"
greeting = f"Hello, {name}!"
```

**Swift:**
```swift
let name = "World"
let greeting = "Hello, \(name)!" // "Hello, World!"
```

### 컬렉션 타입

#### Array (배열)
같은 타입의 값들을 순서대로 저장하는 컬렉션입니다.

**파이썬 (List):**
```python
numbers = [1, 2, 3, 4, 5]
names = ["Alice", "Bob", "Charlie"]
mixed = [1, "hello", True] # 파이썬 리스트는 혼합 타입을 가질 수 있습니다
```

**Swift (Array):**
```swift
var numbers: [Int] = [1, 2, 3, 4, 5]
var names = ["Alice", "Bob", "Charlie"] // [String]으로 추론됨
// var mixed = [1, "hello", true] // 오류: 이종 컬렉션 리터럴은 '[Any]'로만 추론될 수 있습니다

// 빈 배열
var emptyIntArray: [Int] = []
var anotherEmptyArray = [String]()
```
- 요소 접근: `numbers[0]` (두 언어 모두)
- 요소 추가: `numbers.append(6)` (Swift) vs `numbers.append(6)` (파이썬)
- 길이/개수: `numbers.count` (Swift) vs `len(numbers)` (파이썬)

#### Dictionary (딕셔너리)
순서 없는 키-값 쌍의 컬렉션입니다. 키는 같은 타입이어야 하고, 값도 같은 타입이어야 합니다.

**파이썬 (dict):**
```python
person = {
    "name": "Alice",
    "age": 30,
    "city": "New York"
}
scores = {"math": 90, "science": 85}
```

**Swift (Dictionary):**
```swift
var person: [String: Any] = [ // 혼합 값 타입을 위해 Any 사용, 보통 더 구체적으로 지정하려고 노력합니다
    "name": "Alice",
    "age": 30,
    "city": "New York"
]
var scores: [String: Int] = ["math": 90, "science": 85]

// 빈 딕셔너리
var emptyDict: [String: Int] = [:]
var anotherEmptyDict = [String: String]()
```
- 값 접근: `person["name"]` (두 언어 모두). Swift에서는 옵셔널을 반환합니다.
- 추가/업데이트: `scores["english"] = 92` (두 언어 모두)
- 제거: `scores.removeValue(forKey: "math")` (Swift) vs `del scores["math"]` 또는 `scores.pop("math")` (파이썬)

#### Set (세트)
같은 타입의 고유한 값들을 순서 없이 저장하는 컬렉션입니다.

**파이썬 (set):**
```python
unique_numbers = {1, 2, 3, 2, 1} # {1, 2, 3}
```

**Swift (Set):**
```swift
var uniqueNumbers: Set<Int> = [1, 2, 3, 2, 1] // {1, 2, 3}이 됨
var vowels: Set<Character> = ["a", "e", "i", "o", "u"]

// 빈 세트
var emptySet = Set<String>()
```
- 세트 연산 (합집합, 교집합 등)은 두 언어 모두에서 사용 가능합니다.

### 튜플
고정된 크기의, 다른 타입의 값들을 순서대로 가질 수 있는 컬렉션입니다.

**파이썬:**
```python
point = (10, 20)
http_status = (404, "Not Found")
x, y = point
code, message = http_status
```

**Swift:**
```swift
let point = (10, 20)
let httpStatus = (404, "Not Found")

// 요소 접근
let x = point.0       // 10
let y = point.1       // 20

let code = httpStatus.0 // 404
let message = httpStatus.1 // "Not Found"

// 튜플 요소 이름 지정
let namedPoint = (x: 10, y: 20)
print(namedPoint.x) // 10

// 튜플 분해
let (statusCode, statusMessage) = httpStatus
print("상태 코드: \(statusCode)")
```
Swift의 튜플은 명확성을 위해 이름 있는 요소를 허용하는 등 더 강력합니다.

### 옵셔널
Swift는 값의 부재를 처리하기 위해 "옵셔널" 개념을 도입합니다. 옵셔널 변수는 값을 가지거나 `nil`(파이썬의 `None`과 유사)일 수 있습니다. 이는 누락된 값의 가능성을 명시적으로 고려하게 하여 안전한 코드를 작성하기 위한 핵심 기능입니다.

**파이썬:**
```python
def find_user(user_id):
    if user_id == 1:
        return {"name": "Alice"}
    else:
        return None # 사용자를 찾을 수 없음을 나타냄

user = find_user(2)
if user is not None:
    print(user["name"])
else:
    print("사용자를 찾을 수 없습니다.")
```

**Swift:**
```swift
var name: String? // 이 String 변수는 String 또는 nil을 가질 수 있습니다
name = "John Doe"
name = nil

// 옵셔널 String - String 또는 nil일 수 있습니다
var optionalName: String? = "Jane Doe"
// var optionalName: String? = nil

// 강제 언래핑 (주의해서 사용!)
// optionalName이 nil이면 여기서 충돌이 발생합니다.
// let unwrappedName = optionalName!
// print("Hello, \(unwrappedName)")

// 옵셔널 바인딩 (더 안전한 언래핑 방법)
if let unwrappedName = optionalName {
    print("Hello, \(unwrappedName)") // optionalName에 값이 있을 때만 실행됨
} else {
    print("이름이 nil입니다.")
}

// 옵셔널 체이닝
struct User { var profile: Profile? }
struct Profile { var name: String? }
let user: User? = User(profile: Profile(name: "Alice"))

if let userName = user?.profile?.name { // 중첩된 옵셔널에 안전하게 접근
    print("사용자 이름: \(userName)")
} else {
    print("사용자 이름을 가져올 수 없습니다.")
}

// Nil-병합 연산자 (나중에 다룸)
let currentName = optionalName ?? "Guest" // optionalName이 nil이면 "Guest" 사용
print("현재 사용자: \(currentName)")
```
옵셔널을 이해하는 것은 Swift에서 매우 중요합니다.
