# 객체 지향 프로그래밍 (OOP)

### 클래스와 구조체 (`struct`s)
클래스와 구조체 모두 프로퍼티와 메서드를 정의할 수 있습니다.

**주요 차이점:**
- **클래스는 참조 타입입니다:** 클래스 인스턴스를 할당하거나 함수에 전달할 때, 동일한 기존 인스턴스에 대한 참조로 작업합니다. 한 참조를 통해 변경된 사항은 다른 참조를 통해서도 볼 수 있습니다. (파이썬에서 대부분의 객체가 작동하는 방식과 유사합니다).
- **구조체는 값 타입입니다:** 구조체 인스턴스를 할당하거나 함수에 전달할 때, 인스턴스의 복사본이 만들어집니다. 한 복사본의 변경 사항은 다른 복사본에 영향을 미치지 않습니다. (파이썬의 `int`, `str`과 같은 기본 타입 또는 리스트를 명시적으로 복사할 때 `new_list = old_list[:]`와 유사합니다).

- **상속:** 클래스는 상속을 지원하지만 구조체는 지원하지 않습니다.
- **소멸자 (`deinit`):** 클래스는 소멸자를 가질 수 있지만 구조체는 가질 수 없습니다.
- **참조 계산:** 참조 계산은 클래스의 인스턴스에만 적용됩니다.

**구조체는 언제 사용하나요?**
- 작고 간단한 데이터 구조.
- 값 의미론을 원할 때 (복사본은 독립적임).
- 다른 타입으로부터 상속받을 필요가 없을 때.
- 예시: Point, Size, Rectangle, 복소수.

**파이썬 (클래스):**
```python
class Dog:
    def __init__(self, name, breed): # 생성자
        self.name = name
        self.breed = breed
        self.tricks = []

    def bark(self):
        return "Woof!"

    def learn_trick(self, trick_name):
        self.tricks.append(trick_name)

my_dog = Dog("Buddy", "Golden Retriever")
print(my_dog.name)
print(my_dog.bark())
my_dog.learn_trick("sit")

another_dog_ref = my_dog # 둘 다 동일한 객체를 참조합니다
another_dog_ref.learn_trick("fetch")
print(my_dog.tricks) # ['sit', 'fetch']
```

**Swift (클래스 예시):**
```swift
class Dog {
    var name: String
    var breed: String
    var tricks: [String] = [] // 기본 빈 배열로 초기화

    // 초기화 구문 (생성자)
    init(name: String, breed: String) {
        self.name = name // 'self'는 파이썬의 self와 유사합니다
        self.breed = breed
    }

    func bark() -> String {
        return "Woof!"
    }

    func learnTrick(_ trickName: String) {
        tricks.append(trickName)
    }
}

let myDog = Dog(name: "Buddy", breed: "Golden Retriever")
print(myDog.name)
print(myDog.bark())
myDog.learnTrick("sit")

let anotherDogRef = myDog // 둘 다 동일한 Dog 인스턴스를 참조합니다
anotherDogRef.learnTrick("fetch")
print(myDog.tricks) // ["sit", "fetch"]
```

**Swift (구조체 예시):**
```swift
struct Point {
    var x: Double
    var y: Double

    func distance(to otherPoint: Point) -> Double {
        let dx = otherPoint.x - self.x
        let dy = otherPoint.y - self.y
        return (dx*dx + dy*dy).squareRoot() // Double에 squareRoot() 익스텐션이 있다고 가정
    }
}

var p1 = Point(x: 0, y: 0) // 구조체는 사용자 정의 초기화 구문을 정의하지 않으면 멤버별 초기화 구문을 기본으로 얻습니다
var p2 = p1 // p2는 p1의 복사본입니다

p2.x = 10
print(p1.x) // 0.0 (p1은 변경되지 않음)
print(p2.x) // 10.0

let p3 = Point(x:3, y:4)
// p3.x = 5 // 오류: p3는 let 상수이므로, 구조체인 경우 프로퍼티를 변경할 수 없습니다
```
구조체의 인스턴스가 `let` 상수에 할당되면, 해당 프로퍼티가 변수 프로퍼티일지라도 변경할 수 없습니다. 이는 구조체가 값 타입이기 때문입니다. 클래스(참조 타입)의 경우, `let` 상수 인스턴스의 변수 프로퍼티를 변경할 수 있습니다.

### 프로퍼티

프로퍼티는 특정 클래스, 구조체 또는 열거형과 값을 연관시킵니다.

#### 저장 프로퍼티
인스턴스의 일부로 상수(`let`) 또는 변수(`var`) 값을 저장합니다.

```swift
struct FixedLengthRange {
    var firstValue: Int
    let length: Int // 저장 프로퍼티
}
var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)
// 이 범위는 정수 값 0, 1, 2를 나타냅니다
rangeOfThreeItems.firstValue = 6
// 이 범위는 이제 정수 값 6, 7, 8을 나타냅니다
// rangeOfThreeItems.length = 4 // 오류: length는 상수 저장 프로퍼티입니다
```

**지연 저장 프로퍼티:**
처음 사용될 때까지 초기 값이 계산되지 않는 프로퍼티입니다. `lazy var`로 선언합니다. 반드시 `var`여야 합니다. 초기 값이 계산 비용이 많이 들거나 초기화 시 사용할 수 없는 외부 요인에 의존하는 프로퍼티에 유용합니다.

```swift
class DataImporter {
    /* DataImporter는 외부 파일에서 데이터를 가져오는 클래스입니다.
    이 클래스는 초기화하는 데 상당한 시간이 걸린다고 가정합니다. */
    var filename = "data.txt"
    // DataImporter 클래스는 여기서 데이터 가져오기 기능을 제공합니다
    init() {
        print("DataImporter 초기화됨")
    }
}

class DataManager {
    lazy var importer = DataImporter() // importer는 접근될 때까지 생성되지 않습니다
    var data: [String] = []
    // DataManager 클래스는 여기서 데이터 관리 기능을 제공합니다
}

let manager = DataManager() // importer의 DataImporter 인스턴스는 아직 생성되지 않았습니다
manager.data.append("일부 데이터")
manager.data.append("더 많은 데이터")
// importer 프로퍼티의 DataImporter 인스턴스는 여전히 생성되지 않았습니다

print(manager.importer.filename) // 이제 importer 인스턴스가 생성됩니다
// "DataImporter 초기화됨" 출력
// "data.txt" 출력
```

#### 계산 프로퍼티
실제로 값을 저장하지 않습니다. 대신, 다른 프로퍼티와 값을 간접적으로 검색하고 설정하기 위한 getter와 선택적 setter를 제공합니다.

**파이썬 (`@property` 데코레이터 사용):**
```python
class Square:
    def __init__(self, side_length):
        self.side_length = side_length

    @property
    def area(self): # Getter
        return self.side_length ** 2

    @area.setter
    def area(self, new_area):
        self.side_length = new_area ** 0.5

s = Square(5)
print(s.area) # 25
s.area = 36
print(s.side_length) # 6.0
```

**Swift:**
```swift
struct PointStruct { // 충돌을 피하기 위해 Point에서 변경
    var x = 0.0, y = 0.0
}
struct Size {
    var width = 0.0, height = 0.0
}
struct Rect {
    var origin = PointStruct()
    var size = Size()
    var center: PointStruct { // 계산 프로퍼티 'center'
        get { // Getter
            let centerX = origin.x + (size.width / 2)
            let centerY = origin.y + (size.height / 2)
            return PointStruct(x: centerX, y: centerY)
        }
        set(newCenter) { // Setter (선택 사항)
            origin.x = newCenter.x - (size.width / 2)
            origin.y = newCenter.y - (size.height / 2)
        }
        // setter가 정의되지 않으면 읽기 전용 계산 프로퍼티입니다
        // 축약형 setter: 새 값의 이름이 지정되지 않으면 기본적으로 'newValue'가 됩니다
        // set {
        //    origin.x = newValue.x - (size.width / 2)
        //    origin.y = newValue.y - (size.height / 2)
        // }
    }
}

var square = Rect(origin: PointStruct(x: 0.0, y: 0.0),
                  size: Size(width: 10.0, height: 10.0))
let initialSquareCenter = square.center
print("square.origin은 현재 (\(square.origin.x), \(square.origin.y))에 있습니다")
// square.origin은 현재 (0.0, 0.0)에 있습니다
print("square.center는 (\(initialSquareCenter.x), \(initialSquareCenter.y))에 있습니다")
// square.center는 (5.0, 5.0)에 있습니다

square.center = PointStruct(x: 15.0, y: 15.0)
print("square.origin은 현재 (\(square.origin.x), \(square.origin.y))에 있습니다")
// square.origin은 현재 (10.0, 10.0)에 있습니다
```

**프로퍼티 관찰자 (`willSet`, `didSet`):**
프로퍼티 값의 변경에 응답합니다. 새 값이 현재 값과 동일하더라도 프로퍼티 값이 설정될 때마다 호출됩니다.
- `willSet`은 값이 저장되기 직전에 호출됩니다. 새 값은 상수(기본 이름 `newValue`)로 전달됩니다.
- `didSet`은 새 값이 저장된 직후에 호출됩니다. 이전 값은 상수(기본 이름 `oldValue`)로 전달됩니다.

```swift
class StepCounter {
    var totalSteps: Int = 0 {
        willSet(newTotalSteps) {
            print("\(totalSteps)에서 totalSteps를 \(newTotalSteps)(으)로 설정하려고 합니다")
        }
        didSet {
            if totalSteps > oldValue  {
                print("\(totalSteps - oldValue) 걸음 추가됨")
            }
        }
    }
}
let stepCounter = StepCounter()
stepCounter.totalSteps = 200
// 0에서 totalSteps를 200(으)로 설정하려고 합니다
// 200 걸음 추가됨
stepCounter.totalSteps = 360
// 200에서 totalSteps를 360(으)로 설정하려고 합니다
// 160 걸음 추가됨
```

### 메서드

특정 타입과 연관된 함수입니다.

#### 인스턴스 메서드
클래스, 구조체 또는 열거형의 인스턴스에서 호출되는 메서드입니다. (`self`는 현재 인스턴스를 참조합니다).

```swift
class Counter {
    var count = 0
    func increment() {
        self.count += 1 // 모호함이 없으면 self는 선택 사항입니다
    }
    func increment(by amount: Int) {
        count += amount
    }
    func reset() {
        count = 0
    }
}
let counter = Counter()
counter.increment() // count는 1
counter.increment(by: 5) // count는 6
counter.reset() // count는 0
```

**인스턴스 메서드 내에서 값 타입 수정 (`mutating`):**
구조체와 열거형은 값 타입입니다. 기본적으로 값 타입의 프로퍼티는 해당 인스턴스 메서드 내에서 수정할 수 없습니다. 수정을 허용하려면 메서드 앞에 `mutating` 키워드를 붙입니다.

```swift
struct PointValueType { // 충돌을 피하기 위해 이름 변경
    var x = 0.0, y = 0.0
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {
        // self.x += deltaX // 메서드가 mutating이므로 프로퍼티를 수정할 수 있습니다
        // self.y += deltaY
        self = PointValueType(x: self.x + deltaX, y: self.y + deltaY) // 또는 self에 새 구조체를 할당
    }
}
var somePointVal = PointValueType(x: 1.0, y: 1.0)
somePointVal.moveBy(x: 2.0, y: 3.0)
print("점은 이제 (\(somePointVal.x), \(somePointVal.y))에 있습니다")
// "점은 이제 (3.0, 4.0)에 있습니다" 출력

// let fixedPoint = PointValueType(x: 3.0, y: 3.0)
// fixedPoint.moveBy(x: 2.0, y: 3.0) // 오류 발생, 불변 값에 대해 mutating 메서드를 호출할 수 없습니다
```

#### 타입 메서드 (정적 메서드)
인스턴스가 아닌 타입 자체에서 호출됩니다. `static` 키워드를 사용합니다. 클래스의 경우 `class`를 사용하여 하위 클래스가 슈퍼클래스의 구현을 재정의하도록 허용할 수 있습니다.

**파이썬 (`@staticmethod` 또는 `@classmethod` 사용):**
```python
class MathHelper:
    @staticmethod
    def add(x, y):
        return x + y

    @classmethod
    def description(cls):
        return f"이것은 헬퍼 클래스입니다: {cls.__name__}"

MathHelper.add(5,3) # 8
MathHelper.description()
```

**Swift:**
```swift
struct LevelTracker {
    static var highestUnlockedLevel = 1 // 저장 타입 프로퍼티
    static func unlock(_ level: Int) { // 타입 메서드
        if level > highestUnlockedLevel { highestUnlockedLevel = level }
    }
    static func isUnlocked(_ level: Int) -> Bool { // 타입 메서드
        return level <= highestUnlockedLevel
    }
    var currentLevel = 1 // 저장 인스턴스 프로퍼티

    // 이 인스턴스 메서드는 타입 프로퍼티를 쿼리하여 현재 레벨이 잠금 해제되었는지 확인할 수 있습니다
    func advance(to level: Int) -> Bool {
        if LevelTracker.isUnlocked(level) {
            currentLevel = level // 이 부분은 mutating func이어야 수정 가능합니다. 예제에서는 설명을 위해 생략.
            return true
        } else {
            return false
        }
    }
}

// 사용법:
LevelTracker.unlock(2)
LevelTracker.unlock(5)
print(LevelTracker.highestUnlockedLevel) // 5

var playerLevel = LevelTracker() // 인스턴스
print(playerLevel.currentLevel) // 1
// playerLevel.advance는 currentLevel을 변경하려고 하므로 mutating이어야 합니다.
// 이 예제에서는 LevelTracker.isUnlocked를 보여주는 데 중점을 둡니다.
if LevelTracker.isUnlocked(3) { // 직접 타입 메서드 호출
    print("레벨 3은 잠금 해제되었습니다.")
} else {
    print("레벨 3은 잠겨 있습니다.")
}


class SomeClass {
    static func someTypeMethod() {
        print("클래스의 정적 타입 메서드")
    }
    class func overridableTypeMethod() { // 'class'는 재정의를 허용합니다
        print("클래스 타입 메서드 - 재정의 가능")
    }
}
```

### 초기화 (생성자)
초기화 구문 (`init`)은 새 인스턴스를 생성하기 위한 특별한 메서드입니다. 모든 저장 프로퍼티가 초기 값을 갖도록 하는 것이 주된 역할입니다.

**파이썬 (`__init__`):**
```python
class Color:
    def __init__(self, red, green, blue):
        self.red = red
        self.green = green
        self.blue = blue
```

**Swift:**
```swift
struct Color {
    let red, green, blue: Double
    // 초기화 구문
    init(red: Double, green: Double, blue: Double) {
        self.red   = red
        self.green = green
        self.blue  = blue
    }
    // 또 다른 초기화 구문
    init(white: Double) {
        red   = white
        green = white
        blue  = white
    }
}
let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)
let gray = Color(white: 0.5) // init(white:) 호출
```

**기본 초기화 구문:**
- 구조체가 사용자 정의 초기화 구문을 제공하지 않으면 자동으로 *멤버별 초기화 구문*을 얻습니다 (모든 프로퍼티에 기본값이 있거나 옵셔널인 경우 기본 `init()`도 얻음).
  `struct Size { var width = 0.0, height = 0.0 }`
  `let s = Size(width: 10, height: 20)` 또는 `let s = Size()`
- 클래스가 모든 프로퍼티에 기본값을 제공하고 사용자 정의 초기화 구문이 없으면 기본 `init()`을 얻습니다.

**지정 초기화 구문과 편의 초기화 구문 (클래스용):**
- **지정 초기화 구문**은 주 초기화 구문입니다. 해당 클래스에서 도입된 모든 프로퍼티를 완전히 초기화하고 적절한 슈퍼클래스 초기화 구문을 호출합니다. 클래스는 적어도 하나를 가져야 합니다.
- **편의 초기화 구문**은 보조적인 지원 초기화 구문입니다. 동일한 클래스의 다른 초기화 구문을 호출해야 합니다 (결국 지정 초기화 구문을 호출).
  `convenience` 키워드로 표시됩니다.

```swift
class Food {
    var name: String
    // 지정 초기화 구문
    init(name: String) {
        self.name = name
    }
    // 편의 초기화 구문 (동일 클래스의 지정 초기화 구문을 호출해야 함)
    convenience init() {
        self.init(name: "[Unnamed]") // init(name:) 호출
    }
}

class RecipeIngredient: Food {
    var quantity: Int
    // RecipeIngredient의 지정 초기화 구문
    init(name: String, quantity: Int) {
        self.quantity = quantity // 하위 클래스 프로퍼티 먼저 초기화
        super.init(name: name)   // 그런 다음 슈퍼클래스의 지정 초기화 구문 호출
    }
    // 슈퍼클래스의 편의 초기화 구문을 재정의하는 편의 초기화 구문
    // 이 클래스(RecipeIngredient)의 지정 초기화 구문을 호출해야 함
    override convenience init(name: String) {
        self.init(name: name, quantity: 1)
    }
}

let oneMysteryItem = RecipeIngredient() // 편의 init() -> 편의 init(name:) -> 지정 init(name:quantity:) 호출
print(oneMysteryItem.name) // "[Unnamed]"
print(oneMysteryItem.quantity) // 1

let oneBacon = RecipeIngredient(name: "Bacon")
print(oneBacon.name) // "Bacon"
print(oneBacon.quantity) // 1

let sixEggs = RecipeIngredient(name: "Eggs", quantity: 6)
print(sixEggs.name) // "Eggs"
print(sixEggs.quantity) // 6
```

**실패 가능한 초기화 구문 (`init?`, `init!`):**
실패할 수 있는 ( `nil`을 반환할 수 있는) 초기화 구문입니다.

```swift
struct Animal {
    let species: String
    init?(species: String) { // 실패 가능한 초기화 구문
        if species.isEmpty { return nil } // 초기화 실패
        self.species = species
    }
}

let someCreature = Animal(species: "Giraffe") // someCreature는 Animal? 타입입니다
if let giraffe = someCreature {
    print("\(giraffe.species) 종으로 동물이 초기화되었습니다")
}

let anonymousCreature = Animal(species: "") // anonymousCreature는 nil입니다
if anonymousCreature == nil {
    print("익명 동물은 초기화될 수 없었습니다")
}
```

### 소멸화 (소멸자)
소멸자 (`deinit`)는 클래스 인스턴스가 할당 해제되기 직전에 호출됩니다. 클래스에만 해당됩니다.

**파이썬 (`__del__` - 덜 결정적):**
```python
class MyFileHandler:
    def __init__(self, filename):
        self.file = open(filename, 'w')
        print("파일 열림.")
    def __del__(self):
        if self.file:
            self.file.close()
            print("파일 닫힘.") # 객체가 가비지 컬렉션될 때 호출됨

# handler = MyFileHandler("test.txt")
# handler = None # __del__을 트리거할 수 있음
```

**Swift (`deinit`):**
```swift
class Bank {
    static var coinsInBank = 10_000
    static func vendCoins(_ numberOfCoinsToVend: Int) -> Int {
        let numberOfCoinsActuallyVended = min(numberOfCoinsToVend, coinsInBank)
        coinsInBank -= numberOfCoinsActuallyVended
        return numberOfCoinsActuallyVended
    }
    static func receiveCoins(_ coins: Int) {
        coinsInBank += coins
    }
}

class Player {
    var coinsInPurse: Int
    init(coins: Int) {
        coinsInPurse = Bank.vendCoins(coins)
    }
    func winCoins(_ coins: Int) {
        coinsInPurse += Bank.vendCoins(coins)
    }
    deinit { // 소멸자
        Bank.receiveCoins(coinsInPurse) // 은행에 코인 반환
        print("플레이어가 소멸화되었고, \(coinsInPurse) 코인을 은행에 반환했습니다.")
    }
}

var playerOne: Player? = Player(coins: 100)
print("PlayerOne은 \(playerOne!.coinsInPurse) 코인을 가지고 있습니다") // PlayerOne은 100 코인을 가지고 있습니다
print("은행에는 \(Bank.coinsInBank) 코인이 있습니다") // 은행에는 9900 코인이 있습니다

playerOne!.winCoins(2000)
print("PlayerOne은 이제 \(playerOne!.coinsInPurse) 코인을 가지고 있습니다") // PlayerOne은 이제 2100 코인을 가지고 있습니다
print("은행에는 \(Bank.coinsInBank) 코인이 있습니다") // 은행에는 7900 코인이 있습니다

playerOne = nil // Player 인스턴스를 할당 해제하고 deinit이 호출됩니다
// "플레이어가 소멸화되었고, 2100 코인을 은행에 반환했습니다." 출력
print("은행에는 이제 \(Bank.coinsInBank) 코인이 있습니다") // 은행에는 이제 10000 코인이 있습니다
```

### 상속
클래스는 다른 클래스(슈퍼클래스)로부터 메서드, 프로퍼티 및 기타 특성을 상속받을 수 있습니다. 상속받는 클래스는 하위 클래스입니다.

**파이썬:**
```python
class Vehicle:
    def __init__(self, current_speed=0):
        self.current_speed = current_speed

    def make_noise(self):
        print("일반 차량 소음")

class Bicycle(Vehicle): # Bicycle이 Vehicle을 상속합니다
    def __init__(self, has_basket=False):
        super().__init__() # 슈퍼클래스 init 호출
        self.has_basket = has_basket

    def make_noise(self): # 재정의
        print("따르릉 따르릉!")

bike = Bicycle(has_basket=True)
bike.make_noise() # 따르릉 따르릉!
print(bike.current_speed) # 0
```

**Swift:**
```swift
class Vehicle {
    var currentSpeed = 0.0
    var description: String { // 계산 프로퍼티
        return "시속 \(currentSpeed) 마일로 이동 중"
    }
    func makeNoise() {
        // 아무것도 하지 않음 - 임의의 차량이 반드시 소음을 내는 것은 아님
        print("일반 차량 소음 (슈퍼클래스에서)")
    }
}

class Bicycle: Vehicle { // Bicycle이 Vehicle을 상속합니다
    var hasBasket = false
    // 하위 클래스는 기본적으로 슈퍼클래스 초기화 구문을 자동으로 상속하지 않습니다
    // (안전을 위해 특정 조건이 충족되는 경우는 제외).
    // 자체적으로 제공하거나 안전한 경우 상속된 것에 의존해야 합니다.

    // 하위 클래스 초기화 구문이 슈퍼클래스 지정 초기화 구문을 호출하지 않으면,
    // 슈퍼클래스에 인자 없는 init이 있는 경우 Swift가 암시적으로 super.init()을 호출합니다.
    // 여기서 Vehicle에는 사용자 정의 init이 없으므로 기본 init()이 있습니다.
    // Bicycle은 정의하지 않으면 기본 init()을 얻게 됩니다.

    override func makeNoise() { // 'override' 키워드가 필요합니다
        print("따르릉 따르릉!")
    }
}

let bicycle = Bicycle()
bicycle.hasBasket = true
bicycle.currentSpeed = 15.0
print("자전거: \(bicycle.description)") // 자전거: 시속 15.0 마일로 이동 중
bicycle.makeNoise() // 따르릉 따르릉!

class Tandem: Bicycle {
    var currentNumberOfPassengers = 0
}
let tandem = Tandem()
tandem.hasBasket = true
tandem.currentNumberOfPassengers = 2
tandem.currentSpeed = 12.0
print("탠덤 자전거: \(tandem.description)") // 탠덤 자전거: 시속 12.0 마일로 이동 중
tandem.makeNoise() // 따르릉 따르릉! (Bicycle에서 상속)

// 재정의 방지: `final`
// `final var`, `final func`, `final class subscript`, `final class`
// final class Car { ... } // Car는 하위 클래스를 가질 수 없습니다
// class MyCar: Car {} // 오류
```
- 슈퍼클래스 메서드, 프로퍼티 또는 서브스크립트를 재정의하려면 `override` 키워드를 사용합니다.
- `super.`를 사용하여 슈퍼클래스 멤버에 접근합니다 (예: `super.init()`, `super.someMethod()`).

### 프로토콜 (인터페이스)
프로토콜은 특정 작업이나 기능에 적합한 메서드, 프로퍼티 및 기타 요구 사항의 청사진을 정의합니다. 그런 다음 클래스, 구조체 또는 열거형이 프로토콜을 *준수*할 수 있습니다. 이는 Java/C#의 인터페이스 또는 파이썬의 추상 기본 클래스(ABC)와 유사합니다.

**파이썬 (`abc` 모듈 사용):**
```python
from abc import ABC, abstractmethod

class Drawable(ABC):
    @abstractmethod
    def draw(self):
        pass

class Circle(Drawable):
    def draw(self):
        print("원 그리기")

# d = Drawable() # 오류: 추상 클래스를 인스턴스화할 수 없습니다
c = Circle()
c.draw()
```

**Swift:**
```swift
protocol FullyNamed {
    var fullName: String { get } // 가져올 수 있는 프로퍼티 요구 사항
    // 설정 가능한 프로퍼티의 경우: { get set }
    func describe() // 메서드 요구 사항
}

struct Person: FullyNamed { // Person이 FullyNamed를 준수합니다
    var firstName: String
    var lastName: String

    var fullName: String { // 필요한 프로퍼티 구현
        return "\(firstName) \(lastName)"
    }
    func describe() { // 필요한 메서드 구현
        print("이 사람의 이름은 \(fullName)입니다.")
    }
}

struct Pet: FullyNamed {
    var name: String
    var species: String

    var fullName: String {
        return "\(name) (\(species))"
    }
    func describe() {
        print("이 반려동물은 \(fullName)입니다.")
    }
}

let john = Person(firstName: "John", lastName: "Appleseed")
john.describe() // 이 사람의 이름은 John Appleseed입니다.
print(john.fullName) // John Appleseed

let fluffy = Pet(name: "Fluffy", species: "Cat")
fluffy.describe() // 이 반려동물은 Fluffy (Cat)입니다.

// 프로토콜을 타입으로 사용
var someone: FullyNamed
someone = john
print(someone.fullName)
someone = fluffy
print(someone.fullName)

// 프로토콜 요구 사항에는 타입 프로퍼티 및 타입 메서드(정적)가 포함될 수 있습니다
protocol Togglable {
    mutating func toggle() // 인스턴스를 수정하는 경우 'mutating' (값 타입용)
    static var description: String { get }
}

enum OnOffSwitch: Togglable {
    case off, on
    mutating func toggle() {
        switch self {
        case .off:
            self = .on
        case .on:
            self = .off
        }
    }
    static var description: String {
        return "껐다 켰다 할 수 있는 스위치입니다."
    }
}
var lightSwitch = OnOffSwitch.off
lightSwitch.toggle() // lightSwitch는 이제 .on입니다
print(OnOffSwitch.description) // 껐다 켰다 할 수 있는 스위치입니다.
```
프로토콜은 다형성과 코드 재사용(프로토콜 지향 프로그래밍)을 가능하게 하는 Swift 디자인의 기본입니다.

### 익스텐션
기존 클래스, 구조체, 열거형 또는 프로토콜 타입에 새로운 기능을 추가합니다. 여기에는 계산 프로퍼티, 메서드, 초기화 구문, 서브스크립트 추가 및 프로토콜 준수가 포함됩니다.
이는 파이썬의 클래스 몽키 패칭 기능과 유사하지만 더 구조적이고 타입 안전합니다.

```swift
// 내장 Double 타입 확장
extension Double {
    var km: Double { return self * 1_000.0 }
    var m: Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }

    func squared() -> Double {
        return self * self
    }
}

let oneInch = 25.4.mm
print("1인치는 \(oneInch) 미터입니다") // 1인치는 0.0254 미터입니다
let threeFeet = 3.0.ft
print("3피트는 \(threeFeet) 미터입니다") // 3피트는 0.914399970739201 미터입니다

let fiveSquared = 5.0.squared() // 25.0

// 익스텐션을 통한 프로토콜 준수
protocol TextRepresentable {
    var textualDescription: String { get }
}

struct Game {
    var score = 0
    var name: String
}

extension Game: TextRepresentable { // Game이 TextRepresentable을 준수하도록 만듭니다
    var textualDescription: String {
        return "게임: \(name), 점수: \(score)"
    }
}
let myGame = Game(score: 100, name: "Space Invaders")
print(myGame.textualDescription) // 게임: Space Invaders, 점수: 100
```
