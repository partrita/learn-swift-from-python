[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "learn-swift-from-python",
    "section": "",
    "text": "Preface\n이 가이드는 Swift의 기초를 안내하며, 기존 파이썬 지식을 활용할 수 있도록 파이썬과의 비교를 통해 설명합니다.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#목차",
    "href": "index.html#목차",
    "title": "learn-swift-from-python",
    "section": "목차",
    "text": "목차\n\n소개\n\nSwift란?\n왜 Swift인가?\nSwift 대 파이썬: 주요 차이점\n\n시작하기\n\nPlaygrounds\n기본 구문\n\n변수와 상수\n\n선언\n타입 추론\n타입 안전성\n이름 규칙\n\n데이터 타입\n\n기본 타입 (Int, Double, Float, Bool, String)\n컬렉션 타입 (Array, Dictionary, Set)\n튜플\n옵셔널\n\n연산자\n\n산술, 비교, 논리 연산자\nNil-병합 연산자\n범위 연산자\n\n제어 흐름\n\n조건문 (if, else if, else, switch)\n반복문 (for-in, while, repeat-while)\n제어 전달 구문 (continue, break, fallthrough, return, throw)\n\n함수\n\n함수 정의 및 호출\n매개변수와 반환 값\n인자 레이블과 매개변수 이름\n일급 시민으로서의 함수\n클로저\n\n객체 지향 프로그래밍 (OOP)\n\n클래스와 구조체 (structs)\n프로퍼티 (저장 프로퍼티와 계산 프로퍼티)\n메서드 (인스턴스 메서드와 타입 메서드)\n초기화 (생성자)\n소멸화 (소멸자)\n상속\n프로토콜 (인터페이스)\n익스텐션\n\n오류 처리\n\n오류 표현 및 발생\n오류 처리 (do-catch, try?, try!)\n\n메모리 관리 (ARC)\n\n자동 참조 계산\n\n다음 단계",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "ch01.html",
    "href": "ch01.html",
    "title": "1  소개",
    "section": "",
    "text": "1.0.1 Swift란?\nSwift는 macOS, iOS, watchOS, tvOS 등을 위한 강력하고 직관적인 프로그래밍 언어입니다. Apple Inc.와 오픈 소스 커뮤니티에 의해 개발되었습니다.\n\n\n1.0.2 왜 Swift인가?\n\n안전성: 일반적인 프로그래밍 오류의 전체 클래스를 제거하도록 설계되었습니다.\n빠른 속도: C++에 필적하는 성능을 제공합니다.\n현대적: 옵셔널, 제네릭, 클로저와 같은 기능은 표현력이 풍부하고 즐거운 프로그래밍을 가능하게 합니다.\n상호 운용성: Objective-C 코드와 원활하게 작동합니다.\n\n\n\n1.0.3 Swift 대 파이썬: 주요 차이점\n\n\n\n\n\n\n\n\n기능\n파이썬\nSwift\n\n\n\n\n타이핑\n동적 타이핑\n정적 타이핑 (타입 추론 기능 포함)\n\n\n성능\n일반적으로 느림 (인터프리터 방식)\n일반적으로 빠름 (컴파일 방식)\n\n\n오류 처리\n예외 (try-except)\n오류 처리 (do-catch, 옵셔널)\n\n\nNull 안전성\nNone 타입, 처리하지 않으면 런타임 오류 발생\n옵셔널 (?, !)을 통한 명시적 null 처리\n\n\n구문\n들여쓰기 민감\n중괄호 기반 ({})\n\n\n컴파일\n인터프리터 방식 (대부분)\n컴파일 방식\n\n\n모바일 개발\n네이티브 지원 제한적 (Kivy, BeeWare)\niOS, macOS 등의 주요 언어\n\n\n동시성\nGIL이 진정한 병렬 처리에 병목이 될 수 있음\n동시성 내장 지원 (Grand Central Dispatch, async/await)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>소개</span>"
    ]
  },
  {
    "objectID": "ch02.html",
    "href": "ch02.html",
    "title": "2  시작하기",
    "section": "",
    "text": "2.0.1 Playgrounds\nXcode Playgrounds는 Swift 코드를 실험하고 결과를 즉시 확인할 수 있는 대화형 환경을 제공합니다. 이는 파이썬 인터프리터나 Jupyter Notebook을 사용하는 것과 유사합니다.\n\n\n2.0.2 기본 구문\n\n문장은 일반적으로 줄 바꿈으로 끝납니다. 세미콜론 (;)은 한 줄에 여러 문장을 작성하지 않는 한 선택 사항입니다.\n코드 블록은 중괄호 {}로 묶습니다.\n주석:\n\n한 줄 주석: // 이것은 주석입니다\n여러 줄 주석: /* 이것은 여러 줄 주석입니다 */\n\n\n파이썬:\n# 이것은 주석입니다\nname = \"Alice\"\nif name == \"Alice\":\n    print(\"Hello, Alice!\") # 들여쓰기가 중요합니다\nSwift:\n// 이것은 주석입니다\nvar name = \"Alice\" // 변수 선언\nif name == \"Alice\" { // 범위를 위한 중괄호\n    print(\"Hello, Alice!\") // 세미콜론은 선택 사항\n}",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>시작하기</span>"
    ]
  },
  {
    "objectID": "ch03.html",
    "href": "ch03.html",
    "title": "3  변수와 상수",
    "section": "",
    "text": "3.0.1 선언\n\n상수는 let으로 선언합니다. 할당 후에는 값을 변경할 수 없습니다. (한 번 할당된 파이썬 변수를 생각하세요).\n변수는 var로 선언합니다. 값을 변경할 수 있습니다.\n\n파이썬:\n# 파이썬에는 언어 키워드에 의한 엄격한 상수 개념이 없습니다\n# 관례적으로 대문자 이름은 상수를 의미합니다\nMAX_CONNECTIONS = 10\nname = \"Bob\"\nname = \"Charlie\"\nSwift:\nlet maxConnections = 10 // 상수\n// maxConnections = 5 // 컴파일 시간 오류 발생\n\nvar name = \"Bob\"     // 변수\nname = \"Charlie\"\n\n\n3.0.2 타입 추론\nSwift는 종종 초기 값으로부터 변수나 상수의 타입을 추론할 수 있습니다.\n파이썬:\nage = 30 # 타입은 int\npi = 3.14 # 타입은 float\nis_active = True # 타입은 bool\nmessage = \"Hello\" # 타입은 str\nSwift:\nvar age = 30          // Int로 추론됨\nlet pi = 3.14         // Double로 추론됨\nvar isActive = true   // Bool로 추론됨\nlet message = \"Hello\" // String으로 추론됨\n콜론 (:)을 사용하여 타입을 명시적으로 선언할 수도 있습니다.\nSwift:\nvar score: Int = 100\nlet gravity: Double = 9.8\nvar welcomeMessage: String\nwelcomeMessage = \"Hi there!\"\n\n\n3.0.3 타입 안전성\nSwift는 타입 안전 언어입니다. 이는 컴파일러가 컴파일 시간에 타입을 확인하고 타입 불일치를 오류로 표시한다는 것을 의미합니다. 명시적 변환 없이는 한 타입의 값을 다른 타입의 변수에 할당할 수 없습니다.\n파이썬 (동적 타이핑):\nx = 10\nx = \"Python\" # 허용됨, x의 타입이 변경됨\nSwift (정적 타이핑):\nvar x: Int = 10\n// x = \"Swift\" // 컴파일 시간 오류: 'String' 타입의 값을 'Int' 타입에 할당할 수 없습니다\n\n\n3.0.4 이름 규칙\n\n카멜 케이스: Swift는 변수, 상수, 함수, 메서드 이름에 카멜 케이스를 사용합니다 (예: myVariableName, calculateArea).\n어퍼 카멜 케이스 (파스칼 케이스): 클래스, 구조체, 열거형, 프로토콜과 같은 타입 이름에 사용합니다 (예: MyClass, String, Int).\n\n이는 변수와 함수에 snake_case를, 클래스에 CapWords(파스칼 케이스)를 권장하는 파이썬의 PEP 8과 유사합니다.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>변수와 상수</span>"
    ]
  },
  {
    "objectID": "ch04.html",
    "href": "ch04.html",
    "title": "4  데이터 타입",
    "section": "",
    "text": "4.0.1 기본 타입\n\n\n\n\n\n\n\n\n\nSwift 타입\n파이썬 대응\n설명\n예시 (Swift)\n\n\n\n\nInt\nint\n정수\nlet age: Int = 25\n\n\nDouble\nfloat\n64비트 부동 소수점 숫자\nlet pi: Double = 3.14159\n\n\nFloat\nfloat\n32비트 부동 소수점 숫자\nlet price: Float = 19.99\n\n\nBool\nbool\ntrue 또는 false\nlet isValid: Bool = true\n\n\nString\nstr\n문자열\nlet greeting: String = \"Hello\"\n\n\nCharacter\n(단일 문자 str)\n단일 문자\nlet initial: Character = \"J\"\n\n\n\n문자열 보간법: 파이썬의 f-string과 유사합니다.\n파이썬:\nname = \"World\"\ngreeting = f\"Hello, {name}!\"\nSwift:\nlet name = \"World\"\nlet greeting = \"Hello, \\(name)!\" // \"Hello, World!\"\n\n\n4.0.2 컬렉션 타입\n\n4.0.2.1 Array (배열)\n같은 타입의 값들을 순서대로 저장하는 컬렉션입니다.\n파이썬 (List):\nnumbers = [1, 2, 3, 4, 5]\nnames = [\"Alice\", \"Bob\", \"Charlie\"]\nmixed = [1, \"hello\", True] # 파이썬 리스트는 혼합 타입을 가질 수 있습니다\nSwift (Array):\nvar numbers: [Int] = [1, 2, 3, 4, 5]\nvar names = [\"Alice\", \"Bob\", \"Charlie\"] // [String]으로 추론됨\n// var mixed = [1, \"hello\", true] // 오류: 이종 컬렉션 리터럴은 '[Any]'로만 추론될 수 있습니다\n\n// 빈 배열\nvar emptyIntArray: [Int] = []\nvar anotherEmptyArray = [String]()\n\n요소 접근: numbers[0] (두 언어 모두)\n요소 추가: numbers.append(6) (Swift) vs numbers.append(6) (파이썬)\n길이/개수: numbers.count (Swift) vs len(numbers) (파이썬)\n\n\n\n4.0.2.2 Dictionary (딕셔너리)\n순서 없는 키-값 쌍의 컬렉션입니다. 키는 같은 타입이어야 하고, 값도 같은 타입이어야 합니다.\n파이썬 (dict):\nperson = {\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"city\": \"New York\"\n}\nscores = {\"math\": 90, \"science\": 85}\nSwift (Dictionary):\nvar person: [String: Any] = [ // 혼합 값 타입을 위해 Any 사용, 보통 더 구체적으로 지정하려고 노력합니다\n    \"name\": \"Alice\",\n    \"age\": 30,\n    \"city\": \"New York\"\n]\nvar scores: [String: Int] = [\"math\": 90, \"science\": 85]\n\n// 빈 딕셔너리\nvar emptyDict: [String: Int] = [:]\nvar anotherEmptyDict = [String: String]()\n\n값 접근: person[\"name\"] (두 언어 모두). Swift에서는 옵셔널을 반환합니다.\n추가/업데이트: scores[\"english\"] = 92 (두 언어 모두)\n제거: scores.removeValue(forKey: \"math\") (Swift) vs del scores[\"math\"] 또는 scores.pop(\"math\") (파이썬)\n\n\n\n4.0.2.3 Set (세트)\n같은 타입의 고유한 값들을 순서 없이 저장하는 컬렉션입니다.\n파이썬 (set):\nunique_numbers = {1, 2, 3, 2, 1} # {1, 2, 3}\nSwift (Set):\nvar uniqueNumbers: Set&lt;Int&gt; = [1, 2, 3, 2, 1] // {1, 2, 3}이 됨\nvar vowels: Set&lt;Character&gt; = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\n// 빈 세트\nvar emptySet = Set&lt;String&gt;()\n\n세트 연산 (합집합, 교집합 등)은 두 언어 모두에서 사용 가능합니다.\n\n\n\n\n4.0.3 튜플\n고정된 크기의, 다른 타입의 값들을 순서대로 가질 수 있는 컬렉션입니다.\n파이썬:\npoint = (10, 20)\nhttp_status = (404, \"Not Found\")\nx, y = point\ncode, message = http_status\nSwift:\nlet point = (10, 20)\nlet httpStatus = (404, \"Not Found\")\n\n// 요소 접근\nlet x = point.0       // 10\nlet y = point.1       // 20\n\nlet code = httpStatus.0 // 404\nlet message = httpStatus.1 // \"Not Found\"\n\n// 튜플 요소 이름 지정\nlet namedPoint = (x: 10, y: 20)\nprint(namedPoint.x) // 10\n\n// 튜플 분해\nlet (statusCode, statusMessage) = httpStatus\nprint(\"상태 코드: \\(statusCode)\")\nSwift의 튜플은 명확성을 위해 이름 있는 요소를 허용하는 등 더 강력합니다.\n\n\n4.0.4 옵셔널\nSwift는 값의 부재를 처리하기 위해 “옵셔널” 개념을 도입합니다. 옵셔널 변수는 값을 가지거나 nil(파이썬의 None과 유사)일 수 있습니다. 이는 누락된 값의 가능성을 명시적으로 고려하게 하여 안전한 코드를 작성하기 위한 핵심 기능입니다.\n파이썬:\ndef find_user(user_id):\n    if user_id == 1:\n        return {\"name\": \"Alice\"}\n    else:\n        return None # 사용자를 찾을 수 없음을 나타냄\n\nuser = find_user(2)\nif user is not None:\n    print(user[\"name\"])\nelse:\n    print(\"사용자를 찾을 수 없습니다.\")\nSwift:\nvar name: String? // 이 String 변수는 String 또는 nil을 가질 수 있습니다\nname = \"John Doe\"\nname = nil\n\n// 옵셔널 String - String 또는 nil일 수 있습니다\nvar optionalName: String? = \"Jane Doe\"\n// var optionalName: String? = nil\n\n// 강제 언래핑 (주의해서 사용!)\n// optionalName이 nil이면 여기서 충돌이 발생합니다.\n// let unwrappedName = optionalName!\n// print(\"Hello, \\(unwrappedName)\")\n\n// 옵셔널 바인딩 (더 안전한 언래핑 방법)\nif let unwrappedName = optionalName {\n    print(\"Hello, \\(unwrappedName)\") // optionalName에 값이 있을 때만 실행됨\n} else {\n    print(\"이름이 nil입니다.\")\n}\n\n// 옵셔널 체이닝\nstruct User { var profile: Profile? }\nstruct Profile { var name: String? }\nlet user: User? = User(profile: Profile(name: \"Alice\"))\n\nif let userName = user?.profile?.name { // 중첩된 옵셔널에 안전하게 접근\n    print(\"사용자 이름: \\(userName)\")\n} else {\n    print(\"사용자 이름을 가져올 수 없습니다.\")\n}\n\n// Nil-병합 연산자 (나중에 다룸)\nlet currentName = optionalName ?? \"Guest\" // optionalName이 nil이면 \"Guest\" 사용\nprint(\"현재 사용자: \\(currentName)\")\n옵셔널을 이해하는 것은 Swift에서 매우 중요합니다.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>데이터 타입</span>"
    ]
  },
  {
    "objectID": "ch05.html",
    "href": "ch05.html",
    "title": "5  연산자",
    "section": "",
    "text": "5.0.1 산술, 비교, 논리 연산자\n이들은 파이썬과 매우 유사합니다.\n\n산술: +, -, *, /, % (나머지)\n비교: ==, !=, &gt;, &lt;, &gt;=, &lt;=\n논리: && (논리 AND), || (논리 OR), ! (논리 NOT)\n\n파이썬:\na = 10\nb = 3\nprint(a / b)  # 3.333... (부동 소수점 나눗셈)\nprint(a // b) # 3 (정수 나눗셈)\nprint(a % b)  # 1\n\nTrue and False # False\nnot True # False\nSwift:\nlet a = 10\nlet b = 3\n// print(a / b) // a와 b가 Int이면 오류. Int 나눗셈은 Int를 결과로 냄.\nprint(Double(a) / Double(b)) // 3.333... (부동 소수점 나눗셈을 위해 Double로 변환해야 함)\nprint(a / b) // 3 (정수 나눗셈)\nprint(a % b) // 1\n\ntrue && false // false\n!true // false\n나눗셈 참고: Swift에서 Int / Int는 Int를 결과로 냅니다 (소수점 이하 버림). 부동 소수점 나눗셈을 위해서는 피연산자 중 적어도 하나가 부동 소수점 타입이어야 합니다.\n\n\n5.0.2 Nil-병합 연산자 (??)\n옵셔널이 nil일 경우 기본값을 제공합니다.\n파이썬 (종종 or 또는 if 문으로 처리):\nname = None\nusername = name or \"Guest\" # \"Guest\"\n\ndef get_setting(key, default_value):\n    # ... 설정 가져오기 ...\n    if setting_value is None:\n        return default_value\n    return setting_value\nSwift:\nlet defaultColorName = \"red\"\nvar userDefinedColorName: String? // nil 상태\n\nvar colorNameToUse = userDefinedColorName ?? defaultColorName\n// userDefinedColorName이 nil이므로 colorNameToUse는 \"red\"가 됩니다\n\nuserDefinedColorName = \"blue\"\ncolorNameToUse = userDefinedColorName ?? defaultColorName\n// colorNameToUse는 \"blue\"가 됩니다\n구문: a ?? b는 a != nil ? a! : b와 동일합니다.\n\n\n5.0.3 범위 연산자\n\n닫힌 범위 연산자 (a...b): a부터 b까지의 값을 포함합니다. 1...5는 1, 2, 3, 4, 5를 나타냅니다.\n반-열린 범위 연산자 (a..&lt;b): a부터 b 미만까지의 값을 포함합니다. 1..&lt;5는 1, 2, 3, 4를 나타냅니다.\n단방향 범위: a..., ...a, ..&lt;a.\n\n파이썬 (range()):\nfor i in range(1, 6): # 1, 2, 3, 4, 5 (1...5와 유사)\n    print(i)\n\nfor i in range(5): # 0, 1, 2, 3, 4 (0..&lt;5와 유사)\n    print(i)\n\nmy_list = [10, 20, 30, 40, 50]\nmy_list[1:3] # [20, 30] (슬라이싱, 반-열린 범위와 유사)\nSwift:\nfor index in 1...5 {\n    print(index) // 1, 2, 3, 4, 5\n}\n\nfor index in 1..&lt;5 {\n    print(index) // 1, 2, 3, 4\n}\n\nlet names = [\"Anna\", \"Alex\", \"Brian\", \"Jack\"]\nfor name in names[0...2] { // \"Anna\", \"Alex\", \"Brian\"\n    print(name)\n}\nfor name in names[..&lt;2] { // \"Anna\", \"Alex\"\n    print(name)\n}\nfor name in names[2...] { // \"Brian\", \"Jack\"\n    print(name)\n}",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>연산자</span>"
    ]
  },
  {
    "objectID": "ch06.html",
    "href": "ch06.html",
    "title": "6  제어 흐름",
    "section": "",
    "text": "6.0.1 조건문\n\n6.0.1.1 if, else if, else\n구문은 유사하지만, Swift는 단일 문장에도 중괄호 {}를 요구하며 조건 주위의 괄호는 선택 사항이지만 명확성을 위해 종종 사용됩니다.\n파이썬:\ntemperature = 25\nif temperature &gt; 30:\n    print(\"덥습니다!\")\nelif temperature &gt; 20:\n    print(\"따뜻합니다.\")\nelse:\n    print(\"시원합니다.\")\nSwift:\nlet temperature = 25\nif temperature &gt; 30 {\n    print(\"덥습니다!\")\n} else if temperature &gt; 20 {\n    print(\"따뜻합니다.\")\n} else {\n    print(\"시원합니다.\")\n}\n\n\n6.0.1.2 switch\nSwift의 switch 문은 파이썬에 직접적인 switch가 없는 것(파이썬 3.10+에는 match-case가 있음)에 비해 매우 강력하고 유연합니다. - Swift의 switch 문은 모든 가능한 값을 다루거나 default 케이스를 포함해야 합니다 (철저해야 함). - 기본적으로 “fall through”하지 않습니다 (일반적으로 break 필요 없음). C 스타일의 fall-through를 위해서는 fallthrough 키워드를 사용할 수 있습니다. - 범위, 튜플, 값 바인딩 등 다양한 패턴에 대해 일치시킬 수 있습니다.\n파이썬 (if-elif-else 또는 3.10+ match-case 사용):\n# if-elif-else 사용\nvalue = \"a\"\nif value == \"a\":\n    print(\"A입니다\")\nelif value == \"b\":\n    print(\"B입니다\")\nelse:\n    print(\"다른 것입니다\")\n\n# 파이썬 3.10+ match-case\n# match value:\n#     case \"a\":\n#         print(\"A입니다\")\n#     case \"b\":\n#         print(\"B입니다\")\n#     case _:\n#         print(\"다른 것입니다\")\nSwift:\nlet value = \"a\"\nswitch value {\ncase \"a\":\n    print(\"A입니다\")\ncase \"b\", \"c\": // 복합 케이스\n    print(\"B 또는 C입니다\")\ndefault:\n    print(\"다른 것입니다\")\n}\n\nlet approximateCount = 62\nlet countedThings = \"토성 주위를 도는 위성들\"\nvar naturalCount: String\nswitch approximateCount {\ncase 0:\n    naturalCount = \"없음\"\ncase 1..&lt;5:\n    naturalCount = \"몇 개\"\ncase 5..&lt;12:\n    naturalCount = \"여러 개\"\ncase 12..&lt;100:\n    naturalCount = \"수십 개\"\ncase 100..&lt;1000:\n    naturalCount = \"수백 개\"\ndefault:\n    naturalCount = \"많음\"\n}\nprint(\"\\(countedThings)은(는) \\(naturalCount) 있습니다.\") // \"토성 주위를 도는 위성들은 수십 개 있습니다.\"\n\n// 튜플 일치 및 값 바인딩\nlet somePoint = (1, 1)\nswitch somePoint {\ncase (0, 0):\n    print(\"\\(somePoint)은(는) 원점에 있습니다\")\ncase (_, 0): // 와일드카드를 사용한 값 바인딩\n    print(\"\\(somePoint)은(는) x축 위에 있습니다\")\ncase (0, let y): // 'y' 값 바인딩\n    print(\"\\(somePoint)은(는) y축 \\(y)에 있습니다\")\ncase (-2...2, -2...2):\n    print(\"\\(somePoint)은(는) 2x2 상자 안에 있습니다\")\ndefault:\n    print(\"\\(somePoint)은(는) 상자 밖에 있습니다\")\n}\n\n\n\n6.0.2 반복문\n\n6.0.2.1 for-in 반복문\n시퀀스(배열, 범위, 문자열 등)를 반복합니다.\n파이썬:\nnumbers = [1, 2, 3]\nfor num in numbers:\n    print(num)\n\nfor char in \"hello\":\n    print(char)\nSwift:\nlet numbers = [1, 2, 3]\nfor num in numbers {\n    print(num)\n}\n\nfor char in \"hello\" {\n    print(char)\n}\n\n// 딕셔너리 반복\nlet numberOfLegs = [\"spider\": 8, \"ant\": 6, \"cat\": 4]\nfor (animalName, legCount) in numberOfLegs {\n    print(\"\\(animalName)는 다리가 \\(legCount)개 있습니다\")\n}\n\n// 시퀀스의 값이 필요하지 않은 경우:\nfor _ in 1...3 { // 반복 변수가 필요하지 않으면 밑줄 사용\n    print(\"반복 중\")\n}\n\n\n6.0.2.2 while 반복문\n조건이 참인 동안 문장 집합을 실행합니다.\n파이썬:\ncount = 0\nwhile count &lt; 5:\n    print(count)\n    count += 1\nSwift:\nvar count = 0\nwhile count &lt; 5 {\n    print(count)\n    count += 1 // Swift에는 ++ 또는 -- 연산자가 없습니다\n}\n\n\n6.0.2.3 repeat-while 반복문\n다른 언어의 do-while 반복문과 유사합니다. 조건이 확인되기 전에 반복문 본문이 적어도 한 번 실행됩니다.\n파이썬 (while True와 break로 에뮬레이트):\n# 직접적인 repeat-while은 없으며, 종종 에뮬레이트됩니다:\n# count = 0\n# while True:\n#     print(count)\n#     count += 1\n#     if not (count &lt; 5):\n#         break\nSwift:\nvar i = 0\nrepeat {\n    print(\"i의 현재 값: \\(i)\")\n    i += 1\n} while i &lt; 5\n// 이 반복문은 i = 0, 1, 2, 3, 4에 대해 출력합니다\n\n\n\n6.0.3 제어 전달 구문\n\ncontinue: 반복문의 현재 반복을 건너뛰고 다음 반복으로 진행합니다. (파이썬과 동일)\nbreak: 반복문이나 switch 문을 즉시 종료합니다. (파이썬과 동일)\nfallthrough: switch 문에서 실행이 다음 case 블록으로 계속되도록 합니다 (C 스타일 동작).\nreturn: 함수를 종료하고 선택적으로 반환 값을 제공합니다. (파이썬과 동일)\nthrow: 오류 처리에 사용됩니다 (나중에 다룸).\n\nfallthrough를 사용한 Swift 예시:\nlet integerToDescribe = 5\nvar description = \"\\(integerToDescribe)라는 숫자는\"\nswitch integerToDescribe {\ncase 2, 3, 5, 7, 11, 13, 17, 19:\n    description += \" 소수이고, 또한\"\n    fallthrough // 의도적으로 default로 넘어감\ndefault:\n    description += \" 정수입니다.\"\n}\nprint(description) // \"5라는 숫자는 소수이고, 또한 정수입니다.\"",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>제어 흐름</span>"
    ]
  },
  {
    "objectID": "ch07.html",
    "href": "ch07.html",
    "title": "7  함수",
    "section": "",
    "text": "7.0.1 함수 정의 및 호출\n파이썬:\ndef greet(name):\n    return f\"Hello, {name}!\"\n\nmessage = greet(\"Alice\")\nprint(message)\nSwift:\nfunc greet(name: String) -&gt; String { // 매개변수 타입과 반환 타입이 명시적입니다\n    return \"Hello, \\(name)!\"\n}\n\nlet message = greet(name: \"Alice\") // 호출 시 인자 레이블 'name'이 사용됩니다\nprint(message)\n\nSwift 함수는 func 키워드를 사용합니다.\n매개변수 타입과 반환 타입은 반드시 지정해야 합니다.\n-&gt;는 반환 타입을 나타냅니다. 함수가 값을 반환하지 않으면 -&gt; Void를 사용하거나 생략할 수 있습니다.\n\n\n\n7.0.2 매개변수와 반환 값\n여러 매개변수: 파이썬:\ndef add(a, b):\n    return a + b\nSwift:\nfunc add(a: Int, b: Int) -&gt; Int {\n    return a + b\n}\nlet sum = add(a: 5, b: 3)\n매개변수 없음: 파이썬:\ndef say_hello():\n    print(\"Hello!\")\nSwift:\nfunc sayHello() { // 또는 func sayHello() -&gt; Void {\n    print(\"Hello!\")\n}\nsayHello()\n튜플 반환 (여러 값 반환): 파이썬:\ndef get_coordinates():\n    return 10, 20 # 튜플 반환\n\nx, y = get_coordinates()\nSwift:\nfunc getCoordinates() -&gt; (Int, Int) {\n    return (10, 20)\n}\nlet coordinates = getCoordinates()\nprint(\"x: \\(coordinates.0), y: \\(coordinates.1)\")\n\nfunc getNamedCoordinates() -&gt; (x: Int, y: Int) {\n    return (x: 10, y: 20)\n}\nlet namedCoords = getNamedCoordinates()\nprint(\"x: \\(namedCoords.x), y: \\(namedCoords.y)\")\n\n\n7.0.3 인자 레이블과 매개변수 이름\n기본적으로 Swift는 함수를 호출할 때 매개변수 이름을 인자 레이블로 사용합니다.\nfunc someFunction(firstParameterName: Int, secondParameterName: Int) {\n    // 함수 본문에서 firstParameterName은 첫 번째 매개변수 값을,\n    // secondParameterName은 두 번째 매개변수 값을 참조합니다\n}\n// 호출 시 매개변수 이름을 레이블로 사용합니다:\n// someFunction(firstParameterName: 1, secondParameterName: 2)\n다른 인자 레이블 지정: 내부 매개변수 이름과 다른 외부 인자 레이블을 제공할 수 있습니다. 인자 레이블이 없도록 하려면 _를 사용합니다.\nfunc greet(person name: String, from hometown: String) -&gt; String {\n    // 'name'과 'hometown'은 함수 내부에서 사용됩니다\n    return \"Hello \\(name)! \\(hometown)에서 오신 것을 환영합니다.\"\n}\n// 호출 방식:\nprint(greet(person: \"Bill\", from: \"Cupertino\"))\n// 'person'과 'from'이 인자 레이블입니다.\n\nfunc subtract(_ a: Int, by b: Int) -&gt; Int { // 첫 번째 매개변수에 레이블 없음\n    return a - b\n}\nlet result = subtract(10, by: 3) // 호출: subtract(10, by: 3)\n이는 레이블이 항상 매개변수 이름인 파이썬의 키워드 인자와 다릅니다.\n기본 매개변수 값: 파이썬과 유사합니다.\n파이썬:\ndef power(base, exponent=2):\n    return base ** exponent\nSwift:\nfunc power(base: Int, exponent: Int = 2) -&gt; Int {\n    var result = 1\n    for _ in 0..&lt;exponent {\n        result *= base\n    }\n    return result\n}\npower(base: 3) // 9\npower(base: 3, exponent: 3) // 27\n가변 매개변수 (파이썬의 *args와 유사): 지정된 타입의 값을 0개 이상 받습니다.\n파이썬:\ndef average(*numbers):\n    if not numbers:\n        return 0\n    return sum(numbers) / len(numbers)\nSwift:\nfunc average(_ numbers: Double...) -&gt; Double { // numbers는 내부적으로 [Double]입니다\n    if numbers.isEmpty {\n        return 0.0\n    }\n    var total: Double = 0\n    for number in numbers {\n        total += number\n    }\n    return total / Double(numbers.count)\n}\naverage(1.0, 2.0, 3.0) // 2.0\naverage()              // 0.0\nIn-Out 매개변수 (참조에 의한 전달과 같이 매개변수를 직접 수정): 함수 매개변수는 기본적으로 상수입니다. 함수가 매개변수 값을 수정하고 함수 호출이 끝난 후에도 해당 변경 사항이 유지되기를 원하면 해당 매개변수를 in-out 매개변수로 정의합니다. in-out 매개변수에 인수를 전달할 때 변수 이름 바로 앞에 앰퍼샌드(&)를 붙입니다.\n파이썬 (객체는 참조로 전달되며, 가변 타입은 변경될 수 있음):\ndef modify_list(my_list):\n    my_list.append(4)\n\nitems = [1, 2, 3]\nmodify_list(items) # items는 이제 [1, 2, 3, 4]입니다\nSwift:\nfunc swapTwoInts(_ a: inout Int, _ b: inout Int) {\n    let temporaryA = a\n    a = b\n    b = temporaryA\n}\n\nvar someInt = 3\nvar anotherInt = 107\nswapTwoInts(&someInt, &anotherInt) // &를 사용하여 참조로 전달\nprint(\"someInt는 이제 \\(someInt)이고, anotherInt는 이제 \\(anotherInt)입니다\")\n// \"someInt는 이제 107이고, anotherInt는 이제 3입니다\" 출력\n\n\n7.0.4 일급 시민으로서의 함수\n파이썬과 마찬가지로 Swift의 함수는 일급 타입입니다. 변수/상수에 할당하거나, 다른 함수에 인수로 전달하거나, 함수에서 반환할 수 있습니다.\nSwift:\nfunc addTwoInts(_ a: Int, _ b: Int) -&gt; Int {\n    return a + b\n}\n\nvar mathFunction: (Int, Int) -&gt; Int = addTwoInts // mathFunction은 (Int, Int) -&gt; Int 타입입니다\nprint(\"결과: \\(mathFunction(2, 3))\") // 결과: 5\n\nfunc printMathResult(_ mathFunc: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) {\n    print(\"계산 결과: \\(mathFunc(a, b))\")\n}\nprintMathResult(addTwoInts, 10, 5) // \"계산 결과: 15\"\n\nfunc stepForward(_ input: Int) -&gt; Int {\n    return input + 1\n}\nfunc stepBackward(_ input: Int) -&gt; Int {\n    return input - 1\n}\n\nfunc chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int { // 함수를 반환합니다\n    return backward ? stepBackward : stepForward\n}\n\nvar currentValue = 3\nlet moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)\n// moveNearerToZero는 이제 stepBackward() 함수를 참조합니다\nprint(\"0으로 카운트:\")\nwhile currentValue != 0 {\n    print(\"\\(currentValue)... \")\n    currentValue = moveNearerToZero(currentValue)\n}\nprint(\"0!\")\n\n\n7.0.5 클로저\n클로저는 코드 내에서 전달되고 사용될 수 있는 자체 포함된 기능 블록입니다. 파이썬의 lambda 함수와 유사하지만 훨씬 더 강력하고 다재다능하며, Ruby의 블록이나 JavaScript의 익명 함수와 비슷합니다.\n파이썬 Lambda:\nnumbers = [1, 2, 3, 4]\nsquared = list(map(lambda x: x * x, numbers)) # [1, 4, 9, 16]\nSwift 클로저: 클로저는 정의된 컨텍스트의 모든 상수와 변수에 대한 참조를 캡처하고 저장할 수 있습니다 (이를 “클로징 오버”라고 함).\n일반적인 형태:\n{ (매개변수) -&gt; 반환_타입 in\n    // 문장들\n}\nsorted(by:) 메서드 예시:\nlet names = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]\n\n// 정렬을 위해 정의된 함수 사용\nfunc backward(_ s1: String, _ s2: String) -&gt; Bool {\n    return s1 &gt; s2\n}\nvar reversedNames = names.sorted(by: backward) // [\"Ewa\", \"Daniella\", \"Chris\", \"Barry\", \"Alex\"]\n\n// 클로저 표현식 사용\nreversedNames = names.sorted(by: { (s1: String, s2: String) -&gt; Bool in\n    return s1 &gt; s2\n})\n\n// 컨텍스트에서 타입 추론 (Swift는 매개변수 및 반환 값의 타입을 추론할 수 있음)\nreversedNames = names.sorted(by: { s1, s2 in return s1 &gt; s2 })\n\n// 단일 표현식 클로저의 암시적 반환\nreversedNames = names.sorted(by: { s1, s2 in s1 &gt; s2 })\n\n// 축약형 인자 이름 ($0, $1, $2 등)\nreversedNames = names.sorted(by: { $0 &gt; $1 })\n\n// 연산자 메서드 (연산자 함수가 필요한 타입과 일치하는 경우)\nreversedNames = names.sorted(by: &gt;) // 이 경우 가장 간단한 형태\n후행 클로저: 클로저 표현식이 함수의 마지막 인수인 경우, 함수 호출 괄호 뒤에 후행 클로저로 작성할 수 있습니다. 클로저가 유일한 인수인 경우 괄호를 완전히 생략할 수 있습니다.\n// func someFunctionThatTakesAClosure(closure: () -&gt; Void) { /* ... */ }\n\n// 후행 클로저로 호출:\n// someFunctionThatTakesAClosure() {\n//     // 클로저 본문이 여기에 들어갑니다\n// }\n// 또는\n// someFunctionThatTakesAClosure {\n//     // 클로저 본문\n// }\n\nlet numbers = [1, 2, 3, 4]\nlet squaredNumbers = numbers.map { number in // 후행 클로저\n    number * number\n}\nprint(squaredNumbers) // [1, 4, 9, 16]\n\nlet mappedNumbers = numbers.map { number -&gt; String in // 명시적 반환 타입을 가진 후행 클로저\n    return \"숫자: \\(number)\"\n}\nprint(mappedNumbers) // [\"숫자: 1\", \"숫자: 2\", \"숫자: 3\", \"숫자: 4\"]\n클로저는 Swift에서 광범위하게 사용되며, 특히 콜백, 비동기 작업 및 함수형 프로그래밍 패턴에 유용합니다.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>함수</span>"
    ]
  },
  {
    "objectID": "ch08.html",
    "href": "ch08.html",
    "title": "8  객체 지향 프로그래밍 (OOP)",
    "section": "",
    "text": "8.0.1 클래스와 구조체 (structs)\n클래스와 구조체 모두 프로퍼티와 메서드를 정의할 수 있습니다.\n주요 차이점: - 클래스는 참조 타입입니다: 클래스 인스턴스를 할당하거나 함수에 전달할 때, 동일한 기존 인스턴스에 대한 참조로 작업합니다. 한 참조를 통해 변경된 사항은 다른 참조를 통해서도 볼 수 있습니다. (파이썬에서 대부분의 객체가 작동하는 방식과 유사합니다). - 구조체는 값 타입입니다: 구조체 인스턴스를 할당하거나 함수에 전달할 때, 인스턴스의 복사본이 만들어집니다. 한 복사본의 변경 사항은 다른 복사본에 영향을 미치지 않습니다. (파이썬의 int, str과 같은 기본 타입 또는 리스트를 명시적으로 복사할 때 new_list = old_list[:]와 유사합니다).\n\n상속: 클래스는 상속을 지원하지만 구조체는 지원하지 않습니다.\n소멸자 (deinit): 클래스는 소멸자를 가질 수 있지만 구조체는 가질 수 없습니다.\n참조 계산: 참조 계산은 클래스의 인스턴스에만 적용됩니다.\n\n구조체는 언제 사용하나요? - 작고 간단한 데이터 구조. - 값 의미론을 원할 때 (복사본은 독립적임). - 다른 타입으로부터 상속받을 필요가 없을 때. - 예시: Point, Size, Rectangle, 복소수.\n파이썬 (클래스):\nclass Dog:\n    def __init__(self, name, breed): # 생성자\n        self.name = name\n        self.breed = breed\n        self.tricks = []\n\n    def bark(self):\n        return \"Woof!\"\n\n    def learn_trick(self, trick_name):\n        self.tricks.append(trick_name)\n\nmy_dog = Dog(\"Buddy\", \"Golden Retriever\")\nprint(my_dog.name)\nprint(my_dog.bark())\nmy_dog.learn_trick(\"sit\")\n\nanother_dog_ref = my_dog # 둘 다 동일한 객체를 참조합니다\nanother_dog_ref.learn_trick(\"fetch\")\nprint(my_dog.tricks) # ['sit', 'fetch']\nSwift (클래스 예시):\nclass Dog {\n    var name: String\n    var breed: String\n    var tricks: [String] = [] // 기본 빈 배열로 초기화\n\n    // 초기화 구문 (생성자)\n    init(name: String, breed: String) {\n        self.name = name // 'self'는 파이썬의 self와 유사합니다\n        self.breed = breed\n    }\n\n    func bark() -&gt; String {\n        return \"Woof!\"\n    }\n\n    func learnTrick(_ trickName: String) {\n        tricks.append(trickName)\n    }\n}\n\nlet myDog = Dog(name: \"Buddy\", breed: \"Golden Retriever\")\nprint(myDog.name)\nprint(myDog.bark())\nmyDog.learnTrick(\"sit\")\n\nlet anotherDogRef = myDog // 둘 다 동일한 Dog 인스턴스를 참조합니다\nanotherDogRef.learnTrick(\"fetch\")\nprint(myDog.tricks) // [\"sit\", \"fetch\"]\nSwift (구조체 예시):\nstruct Point {\n    var x: Double\n    var y: Double\n\n    func distance(to otherPoint: Point) -&gt; Double {\n        let dx = otherPoint.x - self.x\n        let dy = otherPoint.y - self.y\n        return (dx*dx + dy*dy).squareRoot() // Double에 squareRoot() 익스텐션이 있다고 가정\n    }\n}\n\nvar p1 = Point(x: 0, y: 0) // 구조체는 사용자 정의 초기화 구문을 정의하지 않으면 멤버별 초기화 구문을 기본으로 얻습니다\nvar p2 = p1 // p2는 p1의 복사본입니다\n\np2.x = 10\nprint(p1.x) // 0.0 (p1은 변경되지 않음)\nprint(p2.x) // 10.0\n\nlet p3 = Point(x:3, y:4)\n// p3.x = 5 // 오류: p3는 let 상수이므로, 구조체인 경우 프로퍼티를 변경할 수 없습니다\n구조체의 인스턴스가 let 상수에 할당되면, 해당 프로퍼티가 변수 프로퍼티일지라도 변경할 수 없습니다. 이는 구조체가 값 타입이기 때문입니다. 클래스(참조 타입)의 경우, let 상수 인스턴스의 변수 프로퍼티를 변경할 수 있습니다.\n\n\n8.0.2 프로퍼티\n프로퍼티는 특정 클래스, 구조체 또는 열거형과 값을 연관시킵니다.\n\n8.0.2.1 저장 프로퍼티\n인스턴스의 일부로 상수(let) 또는 변수(var) 값을 저장합니다.\nstruct FixedLengthRange {\n    var firstValue: Int\n    let length: Int // 저장 프로퍼티\n}\nvar rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)\n// 이 범위는 정수 값 0, 1, 2를 나타냅니다\nrangeOfThreeItems.firstValue = 6\n// 이 범위는 이제 정수 값 6, 7, 8을 나타냅니다\n// rangeOfThreeItems.length = 4 // 오류: length는 상수 저장 프로퍼티입니다\n지연 저장 프로퍼티: 처음 사용될 때까지 초기 값이 계산되지 않는 프로퍼티입니다. lazy var로 선언합니다. 반드시 var여야 합니다. 초기 값이 계산 비용이 많이 들거나 초기화 시 사용할 수 없는 외부 요인에 의존하는 프로퍼티에 유용합니다.\nclass DataImporter {\n    /* DataImporter는 외부 파일에서 데이터를 가져오는 클래스입니다.\n    이 클래스는 초기화하는 데 상당한 시간이 걸린다고 가정합니다. */\n    var filename = \"data.txt\"\n    // DataImporter 클래스는 여기서 데이터 가져오기 기능을 제공합니다\n    init() {\n        print(\"DataImporter 초기화됨\")\n    }\n}\n\nclass DataManager {\n    lazy var importer = DataImporter() // importer는 접근될 때까지 생성되지 않습니다\n    var data: [String] = []\n    // DataManager 클래스는 여기서 데이터 관리 기능을 제공합니다\n}\n\nlet manager = DataManager() // importer의 DataImporter 인스턴스는 아직 생성되지 않았습니다\nmanager.data.append(\"일부 데이터\")\nmanager.data.append(\"더 많은 데이터\")\n// importer 프로퍼티의 DataImporter 인스턴스는 여전히 생성되지 않았습니다\n\nprint(manager.importer.filename) // 이제 importer 인스턴스가 생성됩니다\n// \"DataImporter 초기화됨\" 출력\n// \"data.txt\" 출력\n\n\n8.0.2.2 계산 프로퍼티\n실제로 값을 저장하지 않습니다. 대신, 다른 프로퍼티와 값을 간접적으로 검색하고 설정하기 위한 getter와 선택적 setter를 제공합니다.\n파이썬 (@property 데코레이터 사용):\nclass Square:\n    def __init__(self, side_length):\n        self.side_length = side_length\n\n    @property\n    def area(self): # Getter\n        return self.side_length ** 2\n\n    @area.setter\n    def area(self, new_area):\n        self.side_length = new_area ** 0.5\n\ns = Square(5)\nprint(s.area) # 25\ns.area = 36\nprint(s.side_length) # 6.0\nSwift:\nstruct PointStruct { // 충돌을 피하기 위해 Point에서 변경\n    var x = 0.0, y = 0.0\n}\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nstruct Rect {\n    var origin = PointStruct()\n    var size = Size()\n    var center: PointStruct { // 계산 프로퍼티 'center'\n        get { // Getter\n            let centerX = origin.x + (size.width / 2)\n            let centerY = origin.y + (size.height / 2)\n            return PointStruct(x: centerX, y: centerY)\n        }\n        set(newCenter) { // Setter (선택 사항)\n            origin.x = newCenter.x - (size.width / 2)\n            origin.y = newCenter.y - (size.height / 2)\n        }\n        // setter가 정의되지 않으면 읽기 전용 계산 프로퍼티입니다\n        // 축약형 setter: 새 값의 이름이 지정되지 않으면 기본적으로 'newValue'가 됩니다\n        // set {\n        //    origin.x = newValue.x - (size.width / 2)\n        //    origin.y = newValue.y - (size.height / 2)\n        // }\n    }\n}\n\nvar square = Rect(origin: PointStruct(x: 0.0, y: 0.0),\n                  size: Size(width: 10.0, height: 10.0))\nlet initialSquareCenter = square.center\nprint(\"square.origin은 현재 (\\(square.origin.x), \\(square.origin.y))에 있습니다\")\n// square.origin은 현재 (0.0, 0.0)에 있습니다\nprint(\"square.center는 (\\(initialSquareCenter.x), \\(initialSquareCenter.y))에 있습니다\")\n// square.center는 (5.0, 5.0)에 있습니다\n\nsquare.center = PointStruct(x: 15.0, y: 15.0)\nprint(\"square.origin은 현재 (\\(square.origin.x), \\(square.origin.y))에 있습니다\")\n// square.origin은 현재 (10.0, 10.0)에 있습니다\n프로퍼티 관찰자 (willSet, didSet): 프로퍼티 값의 변경에 응답합니다. 새 값이 현재 값과 동일하더라도 프로퍼티 값이 설정될 때마다 호출됩니다. - willSet은 값이 저장되기 직전에 호출됩니다. 새 값은 상수(기본 이름 newValue)로 전달됩니다. - didSet은 새 값이 저장된 직후에 호출됩니다. 이전 값은 상수(기본 이름 oldValue)로 전달됩니다.\nclass StepCounter {\n    var totalSteps: Int = 0 {\n        willSet(newTotalSteps) {\n            print(\"\\(totalSteps)에서 totalSteps를 \\(newTotalSteps)(으)로 설정하려고 합니다\")\n        }\n        didSet {\n            if totalSteps &gt; oldValue  {\n                print(\"\\(totalSteps - oldValue) 걸음 추가됨\")\n            }\n        }\n    }\n}\nlet stepCounter = StepCounter()\nstepCounter.totalSteps = 200\n// 0에서 totalSteps를 200(으)로 설정하려고 합니다\n// 200 걸음 추가됨\nstepCounter.totalSteps = 360\n// 200에서 totalSteps를 360(으)로 설정하려고 합니다\n// 160 걸음 추가됨\n\n\n\n8.0.3 메서드\n특정 타입과 연관된 함수입니다.\n\n8.0.3.1 인스턴스 메서드\n클래스, 구조체 또는 열거형의 인스턴스에서 호출되는 메서드입니다. (self는 현재 인스턴스를 참조합니다).\nclass Counter {\n    var count = 0\n    func increment() {\n        self.count += 1 // 모호함이 없으면 self는 선택 사항입니다\n    }\n    func increment(by amount: Int) {\n        count += amount\n    }\n    func reset() {\n        count = 0\n    }\n}\nlet counter = Counter()\ncounter.increment() // count는 1\ncounter.increment(by: 5) // count는 6\ncounter.reset() // count는 0\n인스턴스 메서드 내에서 값 타입 수정 (mutating): 구조체와 열거형은 값 타입입니다. 기본적으로 값 타입의 프로퍼티는 해당 인스턴스 메서드 내에서 수정할 수 없습니다. 수정을 허용하려면 메서드 앞에 mutating 키워드를 붙입니다.\nstruct PointValueType { // 충돌을 피하기 위해 이름 변경\n    var x = 0.0, y = 0.0\n    mutating func moveBy(x deltaX: Double, y deltaY: Double) {\n        // self.x += deltaX // 메서드가 mutating이므로 프로퍼티를 수정할 수 있습니다\n        // self.y += deltaY\n        self = PointValueType(x: self.x + deltaX, y: self.y + deltaY) // 또는 self에 새 구조체를 할당\n    }\n}\nvar somePointVal = PointValueType(x: 1.0, y: 1.0)\nsomePointVal.moveBy(x: 2.0, y: 3.0)\nprint(\"점은 이제 (\\(somePointVal.x), \\(somePointVal.y))에 있습니다\")\n// \"점은 이제 (3.0, 4.0)에 있습니다\" 출력\n\n// let fixedPoint = PointValueType(x: 3.0, y: 3.0)\n// fixedPoint.moveBy(x: 2.0, y: 3.0) // 오류 발생, 불변 값에 대해 mutating 메서드를 호출할 수 없습니다\n\n\n8.0.3.2 타입 메서드 (정적 메서드)\n인스턴스가 아닌 타입 자체에서 호출됩니다. static 키워드를 사용합니다. 클래스의 경우 class를 사용하여 하위 클래스가 슈퍼클래스의 구현을 재정의하도록 허용할 수 있습니다.\n파이썬 (@staticmethod 또는 @classmethod 사용):\nclass MathHelper:\n    @staticmethod\n    def add(x, y):\n        return x + y\n\n    @classmethod\n    def description(cls):\n        return f\"이것은 헬퍼 클래스입니다: {cls.__name__}\"\n\nMathHelper.add(5,3) # 8\nMathHelper.description()\nSwift:\nstruct LevelTracker {\n    static var highestUnlockedLevel = 1 // 저장 타입 프로퍼티\n    static func unlock(_ level: Int) { // 타입 메서드\n        if level &gt; highestUnlockedLevel { highestUnlockedLevel = level }\n    }\n    static func isUnlocked(_ level: Int) -&gt; Bool { // 타입 메서드\n        return level &lt;= highestUnlockedLevel\n    }\n    var currentLevel = 1 // 저장 인스턴스 프로퍼티\n\n    // 이 인스턴스 메서드는 타입 프로퍼티를 쿼리하여 현재 레벨이 잠금 해제되었는지 확인할 수 있습니다\n    func advance(to level: Int) -&gt; Bool {\n        if LevelTracker.isUnlocked(level) {\n            currentLevel = level // 이 부분은 mutating func이어야 수정 가능합니다. 예제에서는 설명을 위해 생략.\n            return true\n        } else {\n            return false\n        }\n    }\n}\n\n// 사용법:\nLevelTracker.unlock(2)\nLevelTracker.unlock(5)\nprint(LevelTracker.highestUnlockedLevel) // 5\n\nvar playerLevel = LevelTracker() // 인스턴스\nprint(playerLevel.currentLevel) // 1\n// playerLevel.advance는 currentLevel을 변경하려고 하므로 mutating이어야 합니다.\n// 이 예제에서는 LevelTracker.isUnlocked를 보여주는 데 중점을 둡니다.\nif LevelTracker.isUnlocked(3) { // 직접 타입 메서드 호출\n    print(\"레벨 3은 잠금 해제되었습니다.\")\n} else {\n    print(\"레벨 3은 잠겨 있습니다.\")\n}\n\n\nclass SomeClass {\n    static func someTypeMethod() {\n        print(\"클래스의 정적 타입 메서드\")\n    }\n    class func overridableTypeMethod() { // 'class'는 재정의를 허용합니다\n        print(\"클래스 타입 메서드 - 재정의 가능\")\n    }\n}\n\n\n\n8.0.4 초기화 (생성자)\n초기화 구문 (init)은 새 인스턴스를 생성하기 위한 특별한 메서드입니다. 모든 저장 프로퍼티가 초기 값을 갖도록 하는 것이 주된 역할입니다.\n파이썬 (__init__):\nclass Color:\n    def __init__(self, red, green, blue):\n        self.red = red\n        self.green = green\n        self.blue = blue\nSwift:\nstruct Color {\n    let red, green, blue: Double\n    // 초기화 구문\n    init(red: Double, green: Double, blue: Double) {\n        self.red   = red\n        self.green = green\n        self.blue  = blue\n    }\n    // 또 다른 초기화 구문\n    init(white: Double) {\n        red   = white\n        green = white\n        blue  = white\n    }\n}\nlet magenta = Color(red: 1.0, green: 0.0, blue: 1.0)\nlet gray = Color(white: 0.5) // init(white:) 호출\n기본 초기화 구문: - 구조체가 사용자 정의 초기화 구문을 제공하지 않으면 자동으로 멤버별 초기화 구문을 얻습니다 (모든 프로퍼티에 기본값이 있거나 옵셔널인 경우 기본 init()도 얻음). struct Size { var width = 0.0, height = 0.0 } let s = Size(width: 10, height: 20) 또는 let s = Size() - 클래스가 모든 프로퍼티에 기본값을 제공하고 사용자 정의 초기화 구문이 없으면 기본 init()을 얻습니다.\n지정 초기화 구문과 편의 초기화 구문 (클래스용): - 지정 초기화 구문은 주 초기화 구문입니다. 해당 클래스에서 도입된 모든 프로퍼티를 완전히 초기화하고 적절한 슈퍼클래스 초기화 구문을 호출합니다. 클래스는 적어도 하나를 가져야 합니다. - 편의 초기화 구문은 보조적인 지원 초기화 구문입니다. 동일한 클래스의 다른 초기화 구문을 호출해야 합니다 (결국 지정 초기화 구문을 호출). convenience 키워드로 표시됩니다.\nclass Food {\n    var name: String\n    // 지정 초기화 구문\n    init(name: String) {\n        self.name = name\n    }\n    // 편의 초기화 구문 (동일 클래스의 지정 초기화 구문을 호출해야 함)\n    convenience init() {\n        self.init(name: \"[Unnamed]\") // init(name:) 호출\n    }\n}\n\nclass RecipeIngredient: Food {\n    var quantity: Int\n    // RecipeIngredient의 지정 초기화 구문\n    init(name: String, quantity: Int) {\n        self.quantity = quantity // 하위 클래스 프로퍼티 먼저 초기화\n        super.init(name: name)   // 그런 다음 슈퍼클래스의 지정 초기화 구문 호출\n    }\n    // 슈퍼클래스의 편의 초기화 구문을 재정의하는 편의 초기화 구문\n    // 이 클래스(RecipeIngredient)의 지정 초기화 구문을 호출해야 함\n    override convenience init(name: String) {\n        self.init(name: name, quantity: 1)\n    }\n}\n\nlet oneMysteryItem = RecipeIngredient() // 편의 init() -&gt; 편의 init(name:) -&gt; 지정 init(name:quantity:) 호출\nprint(oneMysteryItem.name) // \"[Unnamed]\"\nprint(oneMysteryItem.quantity) // 1\n\nlet oneBacon = RecipeIngredient(name: \"Bacon\")\nprint(oneBacon.name) // \"Bacon\"\nprint(oneBacon.quantity) // 1\n\nlet sixEggs = RecipeIngredient(name: \"Eggs\", quantity: 6)\nprint(sixEggs.name) // \"Eggs\"\nprint(sixEggs.quantity) // 6\n실패 가능한 초기화 구문 (init?, init!): 실패할 수 있는 ( nil을 반환할 수 있는) 초기화 구문입니다.\nstruct Animal {\n    let species: String\n    init?(species: String) { // 실패 가능한 초기화 구문\n        if species.isEmpty { return nil } // 초기화 실패\n        self.species = species\n    }\n}\n\nlet someCreature = Animal(species: \"Giraffe\") // someCreature는 Animal? 타입입니다\nif let giraffe = someCreature {\n    print(\"\\(giraffe.species) 종으로 동물이 초기화되었습니다\")\n}\n\nlet anonymousCreature = Animal(species: \"\") // anonymousCreature는 nil입니다\nif anonymousCreature == nil {\n    print(\"익명 동물은 초기화될 수 없었습니다\")\n}\n\n\n8.0.5 소멸화 (소멸자)\n소멸자 (deinit)는 클래스 인스턴스가 할당 해제되기 직전에 호출됩니다. 클래스에만 해당됩니다.\n파이썬 (__del__ - 덜 결정적):\nclass MyFileHandler:\n    def __init__(self, filename):\n        self.file = open(filename, 'w')\n        print(\"파일 열림.\")\n    def __del__(self):\n        if self.file:\n            self.file.close()\n            print(\"파일 닫힘.\") # 객체가 가비지 컬렉션될 때 호출됨\n\n# handler = MyFileHandler(\"test.txt\")\n# handler = None # __del__을 트리거할 수 있음\nSwift (deinit):\nclass Bank {\n    static var coinsInBank = 10_000\n    static func vendCoins(_ numberOfCoinsToVend: Int) -&gt; Int {\n        let numberOfCoinsActuallyVended = min(numberOfCoinsToVend, coinsInBank)\n        coinsInBank -= numberOfCoinsActuallyVended\n        return numberOfCoinsActuallyVended\n    }\n    static func receiveCoins(_ coins: Int) {\n        coinsInBank += coins\n    }\n}\n\nclass Player {\n    var coinsInPurse: Int\n    init(coins: Int) {\n        coinsInPurse = Bank.vendCoins(coins)\n    }\n    func winCoins(_ coins: Int) {\n        coinsInPurse += Bank.vendCoins(coins)\n    }\n    deinit { // 소멸자\n        Bank.receiveCoins(coinsInPurse) // 은행에 코인 반환\n        print(\"플레이어가 소멸화되었고, \\(coinsInPurse) 코인을 은행에 반환했습니다.\")\n    }\n}\n\nvar playerOne: Player? = Player(coins: 100)\nprint(\"PlayerOne은 \\(playerOne!.coinsInPurse) 코인을 가지고 있습니다\") // PlayerOne은 100 코인을 가지고 있습니다\nprint(\"은행에는 \\(Bank.coinsInBank) 코인이 있습니다\") // 은행에는 9900 코인이 있습니다\n\nplayerOne!.winCoins(2000)\nprint(\"PlayerOne은 이제 \\(playerOne!.coinsInPurse) 코인을 가지고 있습니다\") // PlayerOne은 이제 2100 코인을 가지고 있습니다\nprint(\"은행에는 \\(Bank.coinsInBank) 코인이 있습니다\") // 은행에는 7900 코인이 있습니다\n\nplayerOne = nil // Player 인스턴스를 할당 해제하고 deinit이 호출됩니다\n// \"플레이어가 소멸화되었고, 2100 코인을 은행에 반환했습니다.\" 출력\nprint(\"은행에는 이제 \\(Bank.coinsInBank) 코인이 있습니다\") // 은행에는 이제 10000 코인이 있습니다\n\n\n8.0.6 상속\n클래스는 다른 클래스(슈퍼클래스)로부터 메서드, 프로퍼티 및 기타 특성을 상속받을 수 있습니다. 상속받는 클래스는 하위 클래스입니다.\n파이썬:\nclass Vehicle:\n    def __init__(self, current_speed=0):\n        self.current_speed = current_speed\n\n    def make_noise(self):\n        print(\"일반 차량 소음\")\n\nclass Bicycle(Vehicle): # Bicycle이 Vehicle을 상속합니다\n    def __init__(self, has_basket=False):\n        super().__init__() # 슈퍼클래스 init 호출\n        self.has_basket = has_basket\n\n    def make_noise(self): # 재정의\n        print(\"따르릉 따르릉!\")\n\nbike = Bicycle(has_basket=True)\nbike.make_noise() # 따르릉 따르릉!\nprint(bike.current_speed) # 0\nSwift:\nclass Vehicle {\n    var currentSpeed = 0.0\n    var description: String { // 계산 프로퍼티\n        return \"시속 \\(currentSpeed) 마일로 이동 중\"\n    }\n    func makeNoise() {\n        // 아무것도 하지 않음 - 임의의 차량이 반드시 소음을 내는 것은 아님\n        print(\"일반 차량 소음 (슈퍼클래스에서)\")\n    }\n}\n\nclass Bicycle: Vehicle { // Bicycle이 Vehicle을 상속합니다\n    var hasBasket = false\n    // 하위 클래스는 기본적으로 슈퍼클래스 초기화 구문을 자동으로 상속하지 않습니다\n    // (안전을 위해 특정 조건이 충족되는 경우는 제외).\n    // 자체적으로 제공하거나 안전한 경우 상속된 것에 의존해야 합니다.\n\n    // 하위 클래스 초기화 구문이 슈퍼클래스 지정 초기화 구문을 호출하지 않으면,\n    // 슈퍼클래스에 인자 없는 init이 있는 경우 Swift가 암시적으로 super.init()을 호출합니다.\n    // 여기서 Vehicle에는 사용자 정의 init이 없으므로 기본 init()이 있습니다.\n    // Bicycle은 정의하지 않으면 기본 init()을 얻게 됩니다.\n\n    override func makeNoise() { // 'override' 키워드가 필요합니다\n        print(\"따르릉 따르릉!\")\n    }\n}\n\nlet bicycle = Bicycle()\nbicycle.hasBasket = true\nbicycle.currentSpeed = 15.0\nprint(\"자전거: \\(bicycle.description)\") // 자전거: 시속 15.0 마일로 이동 중\nbicycle.makeNoise() // 따르릉 따르릉!\n\nclass Tandem: Bicycle {\n    var currentNumberOfPassengers = 0\n}\nlet tandem = Tandem()\ntandem.hasBasket = true\ntandem.currentNumberOfPassengers = 2\ntandem.currentSpeed = 12.0\nprint(\"탠덤 자전거: \\(tandem.description)\") // 탠덤 자전거: 시속 12.0 마일로 이동 중\ntandem.makeNoise() // 따르릉 따르릉! (Bicycle에서 상속)\n\n// 재정의 방지: `final`\n// `final var`, `final func`, `final class subscript`, `final class`\n// final class Car { ... } // Car는 하위 클래스를 가질 수 없습니다\n// class MyCar: Car {} // 오류\n\n슈퍼클래스 메서드, 프로퍼티 또는 서브스크립트를 재정의하려면 override 키워드를 사용합니다.\nsuper.를 사용하여 슈퍼클래스 멤버에 접근합니다 (예: super.init(), super.someMethod()).\n\n\n\n8.0.7 프로토콜 (인터페이스)\n프로토콜은 특정 작업이나 기능에 적합한 메서드, 프로퍼티 및 기타 요구 사항의 청사진을 정의합니다. 그런 다음 클래스, 구조체 또는 열거형이 프로토콜을 준수할 수 있습니다. 이는 Java/C#의 인터페이스 또는 파이썬의 추상 기본 클래스(ABC)와 유사합니다.\n파이썬 (abc 모듈 사용):\nfrom abc import ABC, abstractmethod\n\nclass Drawable(ABC):\n    @abstractmethod\n    def draw(self):\n        pass\n\nclass Circle(Drawable):\n    def draw(self):\n        print(\"원 그리기\")\n\n# d = Drawable() # 오류: 추상 클래스를 인스턴스화할 수 없습니다\nc = Circle()\nc.draw()\nSwift:\nprotocol FullyNamed {\n    var fullName: String { get } // 가져올 수 있는 프로퍼티 요구 사항\n    // 설정 가능한 프로퍼티의 경우: { get set }\n    func describe() // 메서드 요구 사항\n}\n\nstruct Person: FullyNamed { // Person이 FullyNamed를 준수합니다\n    var firstName: String\n    var lastName: String\n\n    var fullName: String { // 필요한 프로퍼티 구현\n        return \"\\(firstName) \\(lastName)\"\n    }\n    func describe() { // 필요한 메서드 구현\n        print(\"이 사람의 이름은 \\(fullName)입니다.\")\n    }\n}\n\nstruct Pet: FullyNamed {\n    var name: String\n    var species: String\n\n    var fullName: String {\n        return \"\\(name) (\\(species))\"\n    }\n    func describe() {\n        print(\"이 반려동물은 \\(fullName)입니다.\")\n    }\n}\n\nlet john = Person(firstName: \"John\", lastName: \"Appleseed\")\njohn.describe() // 이 사람의 이름은 John Appleseed입니다.\nprint(john.fullName) // John Appleseed\n\nlet fluffy = Pet(name: \"Fluffy\", species: \"Cat\")\nfluffy.describe() // 이 반려동물은 Fluffy (Cat)입니다.\n\n// 프로토콜을 타입으로 사용\nvar someone: FullyNamed\nsomeone = john\nprint(someone.fullName)\nsomeone = fluffy\nprint(someone.fullName)\n\n// 프로토콜 요구 사항에는 타입 프로퍼티 및 타입 메서드(정적)가 포함될 수 있습니다\nprotocol Togglable {\n    mutating func toggle() // 인스턴스를 수정하는 경우 'mutating' (값 타입용)\n    static var description: String { get }\n}\n\nenum OnOffSwitch: Togglable {\n    case off, on\n    mutating func toggle() {\n        switch self {\n        case .off:\n            self = .on\n        case .on:\n            self = .off\n        }\n    }\n    static var description: String {\n        return \"껐다 켰다 할 수 있는 스위치입니다.\"\n    }\n}\nvar lightSwitch = OnOffSwitch.off\nlightSwitch.toggle() // lightSwitch는 이제 .on입니다\nprint(OnOffSwitch.description) // 껐다 켰다 할 수 있는 스위치입니다.\n프로토콜은 다형성과 코드 재사용(프로토콜 지향 프로그래밍)을 가능하게 하는 Swift 디자인의 기본입니다.\n\n\n8.0.8 익스텐션\n기존 클래스, 구조체, 열거형 또는 프로토콜 타입에 새로운 기능을 추가합니다. 여기에는 계산 프로퍼티, 메서드, 초기화 구문, 서브스크립트 추가 및 프로토콜 준수가 포함됩니다. 이는 파이썬의 클래스 몽키 패칭 기능과 유사하지만 더 구조적이고 타입 안전합니다.\n// 내장 Double 타입 확장\nextension Double {\n    var km: Double { return self * 1_000.0 }\n    var m: Double { return self }\n    var cm: Double { return self / 100.0 }\n    var mm: Double { return self / 1_000.0 }\n    var ft: Double { return self / 3.28084 }\n\n    func squared() -&gt; Double {\n        return self * self\n    }\n}\n\nlet oneInch = 25.4.mm\nprint(\"1인치는 \\(oneInch) 미터입니다\") // 1인치는 0.0254 미터입니다\nlet threeFeet = 3.0.ft\nprint(\"3피트는 \\(threeFeet) 미터입니다\") // 3피트는 0.914399970739201 미터입니다\n\nlet fiveSquared = 5.0.squared() // 25.0\n\n// 익스텐션을 통한 프로토콜 준수\nprotocol TextRepresentable {\n    var textualDescription: String { get }\n}\n\nstruct Game {\n    var score = 0\n    var name: String\n}\n\nextension Game: TextRepresentable { // Game이 TextRepresentable을 준수하도록 만듭니다\n    var textualDescription: String {\n        return \"게임: \\(name), 점수: \\(score)\"\n    }\n}\nlet myGame = Game(score: 100, name: \"Space Invaders\")\nprint(myGame.textualDescription) // 게임: Space Invaders, 점수: 100",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>객체 지향 프로그래밍 (OOP)</span>"
    ]
  },
  {
    "objectID": "ch09.html",
    "href": "ch09.html",
    "title": "9  오류 처리",
    "section": "",
    "text": "Swift는 런타임에 복구 가능한 오류를 발생시키고, 잡고, 전파하고, 조작하기 위한 일급 지원을 제공합니다. 이는 값의 부재를 처리하는 옵셔널과 다릅니다. 오류 처리는 작업의 예기치 않은 결과를 다룹니다.\n파이썬은 예외 처리를 위해 try-except-finally 블록을 사용합니다.\n\n9.0.1 오류 표현 및 발생\nSwift에서 오류는 Error 프로토콜(빈 프로토콜)을 준수하는 타입의 값으로 표현됩니다. 열거형은 관련된 오류 조건 그룹을 모델링하는 데 종종 적합합니다.\nenum VendingMachineError: Error { // Error 프로토콜 준수\n    case invalidSelection\n    case insufficientFunds(coinsNeeded: Int)\n    case outOfStock\n}\n\n// 오류 발생\n// throw VendingMachineError.insufficientFunds(coinsNeeded: 5)\n\n\n9.0.2 오류 처리\n함수가 오류를 발생시키면 프로그램 흐름이 변경됩니다.\n\n9.0.2.1 throws를 사용하여 오류 전파\n함수는 선언에 throws 키워드를 포함하여 오류를 발생시킬 수 있음을 나타냅니다. throws 함수를 호출하는 경우 오류를 처리하거나(do-catch, try? 또는 try! 사용) 현재 함수도 throws로 표시하여 오류를 전파해야 합니다.\nstruct Item {\n    var price: Int\n    var count: Int\n}\n\nclass VendingMachine {\n    var inventory = [\n        \"Candy Bar\": Item(price: 12, count: 7),\n        \"Chips\": Item(price: 10, count: 4),\n        \"Pretzels\": Item(price: 7, count: 11)\n    ]\n    var coinsDeposited = 0\n\n    func vend(itemNamed name: String) throws { // 이 함수는 오류를 발생시킬 수 있습니다\n        guard let item = inventory[name] else {\n            throw VendingMachineError.invalidSelection\n        }\n        guard item.count &gt; 0 else {\n            throw VendingMachineError.outOfStock\n        }\n        guard item.price &lt;= coinsDeposited else {\n            throw VendingMachineError.insufficientFunds(coinsNeeded: item.price - coinsDeposited)\n        }\n\n        coinsDeposited -= item.price\n        var newItem = item\n        newItem.count -= 1\n        inventory[name] = newItem\n\n        print(\"\\(name) 제공 중\")\n    }\n}\n\n\n9.0.2.2 do-catch를 사용하여 오류 처리\ndo-catch 문은 코드 블록을 실행합니다. do 절 내에서 오류가 발생하면 catch 절과 일치시켜 어떤 절이 오류를 처리할 수 있는지 결정합니다.\nlet favoriteSnacks = [\n    \"Alice\": \"Chips\",\n    \"Bob\": \"Licorice\", // 오류 발생 원인\n    \"Eve\": \"Pretzels\",\n]\n\nfunc buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws {\n    let snackName = favoriteSnacks[person] ?? \"Candy Bar\"\n    try vendingMachine.vend(itemNamed: snackName) // 'try' 키워드 필요\n}\n\nvar vendingMachine = VendingMachine()\nvendingMachine.coinsDeposited = 100\n\n// 예제 1: 특정 오류 잡기\nfunc attemptToBuySnack(person: String) {\n    do {\n        try buyFavoriteSnack(person: person, vendingMachine: vendingMachine)\n        print(\"\\(person)을(를) 위한 간식을 성공적으로 구매했습니다.\")\n    } catch VendingMachineError.invalidSelection {\n        print(\"\\(person)에 대한 잘못된 선택입니다.\")\n    } catch VendingMachineError.outOfStock {\n        print(\"\\(person)에 대한 재고가 없습니다.\")\n    } catch VendingMachineError.insufficientFunds(let coinsNeeded) {\n        print(\"\\(person)에 대한 자금이 부족합니다. \\(coinsNeeded) 코인을 추가로 넣어주세요.\")\n    } catch { // 일반 catch 블록 (오류는 'error'로 암시적으로 사용 가능)\n        print(\"\\(person)에 대한 예기치 않은 오류: \\(error).\")\n    }\n}\n\nattemptToBuySnack(person: \"Alice\") // Alice를 위한 간식을 성공적으로 구매했습니다. (칩 가격 &lt;= 100 가정)\n// (칩 구매 후, coinsDeposited가 이제 90이라고 가정)\nattemptToBuySnack(person: \"Bob\")   // Bob에 대한 잘못된 선택입니다. (Licorice 재고 없음)\nattemptToBuySnack(person: \"Eve\")   // Eve를 위한 간식을 성공적으로 구매했습니다. (프레첼 가격 &lt;= 90 가정)\n\n// 예제 2: 오류 전파\n// func someFunctionThatCallsThrowingFunction() throws {\n//     try vendingMachine.vend(itemNamed: \"Candy Bar\")\n// }\n\n\n9.0.2.3 오류를 옵셔널 값으로 변환 (try?)\ntry?를 사용하여 오류를 옵셔널 값으로 변환하여 처리합니다. try? 표현식을 평가하는 동안 오류가 발생하면 표현식의 값은 nil이 됩니다.\n// func someThrowingFunction() throws -&gt; Int { /* ... */ }\n\nlet x = try? someThrowingFunction() // x는 Int? 타입입니다\n// someThrowingFunction이 오류를 발생시키면 x는 nil이 됩니다. 그렇지 않으면 x는 반환된 Int입니다.\n\n// vend 예제:\nfunc fetchData() -&gt; Data? { // 데이터를 반환하거나 nil을 반환할 수 있는 예제 함수\n    if let data = try? Data(contentsOf: URL(string: \"http://example.com/data.txt\")!) {\n        return data\n    } else {\n        print(\"데이터를 가져올 수 없습니다.\")\n        return nil\n    }\n}\n\n\n9.0.2.4 오류 전파 비활성화 (try!)\n던지는 함수나 메서드가 런타임에 실제로 오류를 발생시키지 않을 것이라고 확신할 때 try!를 사용합니다. 오류가 발생하면 런타임 오류(크래시)가 발생합니다. 극도의 주의를 기울여 사용하십시오.\n// let photo = try! loadImage(atPath: \"./Resources/JohnAppleseed.jpg\")\n// 이 코드는 해당 경로에 대해 loadImage가 절대 실패하지 않을 것이라고 가정합니다.\n\n\n9.0.2.5 정리 작업 지정 (defer)\ndefer 문은 실행이 현재 범위를 벗어나기 직전에 코드 블록을 실행합니다 (예: 함수 반환, 오류 발생, 반복문 중단). 리소스 정리에 유용합니다. defer 문은 나타난 순서의 역순으로 실행됩니다.\n파이썬 (finally 사용):\n# file = None\n# try:\n#     file = open(\"myfile.txt\", \"r\")\n#     # 파일 처리\n# finally:\n#     if file:\n#         file.close()\n#         print(\"finally에서 파일 닫힘.\")\nSwift:\nfunc processFile(filename: String) throws {\n    let file = open(filename, O_RDONLY) // C 스타일 파일 열기\n    if file == -1 {\n        // throw FileError.couldNotOpen\n        print(\"파일을 열 수 없습니다.\")\n        return\n    }\n    defer { // 범위가 종료될 때 실행됨 (반환 또는 오류)\n        close(file)\n        print(\"defer에서 파일 닫힘.\")\n    }\n\n    // 파일 작업...\n    // 여기서 오류가 발생하거나 함수가 반환되면 defer 블록이 여전히 실행됩니다.\n    print(\"파일 처리 중...\")\n    // 작업 시뮬레이션, 오류 발생 가능성\n    // if someCondition { throw FileError.readFailed }\n}\n\n// try processFile(filename: \"example.txt\")",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>오류 처리</span>"
    ]
  },
  {
    "objectID": "ch10.html",
    "href": "ch10.html",
    "title": "10  메모리 관리 (ARC)",
    "section": "",
    "text": "Swift는 클래스 인스턴스의 메모리를 관리하기 위해 자동 참조 계산(ARC)을 사용합니다. ARC는 해당 인스턴스가 더 이상 필요하지 않을 때 클래스 인스턴스에서 사용한 메모리를 자동으로 해제합니다. - 일반적으로 메모리 관리에 대해 직접 생각할 필요가 없습니다. - ARC는 각 클래스 인스턴스를 현재 참조하고 있는 프로퍼티, 상수 및 변수가 몇 개인지 추적하여 작동합니다. 해당 인스턴스에 대한 활성 참조가 하나 이상 존재하는 한 인스턴스를 할당 해제하지 않습니다. - 강한 참조 순환: ARC는 때때로 두 클래스 인스턴스가 서로 강한 참조를 유지하여 절대 할당 해제되지 않는 상황(메모리 누수)을 유발할 수 있습니다. Swift는 이러한 순환을 해결하기 위해 weak 및 unowned 참조를 제공합니다. - weak 참조: 약한 참조는 참조하는 인스턴스에 대한 강한 유지를 하지 않으므로 ARC가 참조된 인스턴스를 할당 해제하는 것을 막지 않습니다. 인스턴스가 할당 해제되면 참조는 nil이 됩니다. 따라서 약한 참조는 옵셔널 타입이어야 합니다. - unowned 참조: 약한 참조와 마찬가지로 미소유 참조는 강한 유지를 하지 않습니다. 그러나 미소유 참조는 다른 인스턴스가 동일한 수명 또는 더 긴 수명을 가질 때 사용됩니다. 항상 값을 가질 것으로 가정됩니다. 인스턴스가 할당 해제된 후 미소유 참조에 접근하면 런타임 오류가 발생합니다.\n파이썬 (가비지 컬렉션): 파이썬은 참조 계산과 순환 가비지 컬렉터의 조합을 사용하여 메모리를 관리합니다. 일반적으로 메모리를 수동으로 관리하지 않습니다.\nSwift (ARC 예제 - 강한 참조 순환):\nclass PersonARC {\n    let name: String\n    init(name: String) { self.name = name }\n    var apartment: ApartmentARC? // 옵셔널, nil일 수 있음\n    deinit { print(\"\\(name)이(가) 소멸화 중입니다 (Person)\") }\n}\n\nclass ApartmentARC {\n    let unit: String\n    init(unit: String) { self.unit = unit }\n    // weak var tenant: PersonARC? // 순환을 끊으려면 weak 사용\n    var tenant: PersonARC? // 기본적으로 강한 참조\n    deinit { print(\"아파트 \\(unit)이(가) 소멸화 중입니다\") }\n}\n\nvar johnArc: PersonARC?\nvar unit4A: ApartmentARC?\n\njohnArc = PersonARC(name: \"John Appleseed\")\nunit4A = ApartmentARC(unit: \"4A\")\n\n// 강한 참조 순환 생성:\njohnArc!.apartment = unit4A\nunit4A!.tenant = johnArc // tenant가 weak가 아니면 순환이 생성됨\n\n// 둘 다 nil로 설정합니다. 순환이 있으면 deinit이 호출되지 않습니다.\njohnArc = nil\nunit4A = nil\n// ApartmentARC의 'tenant'가 'var tenant: PersonARC?'이면 deinit 메시지가 출력되지 않습니다.\n// ApartmentARC의 'tenant'가 'weak var tenant: PersonARC?'이면 deinit 메시지가 출력됩니다.\n위의 순환을 끊으려면 ApartmentARC의 tenant를 weak var tenant: PersonARC?로 선언해야 합니다.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>메모리 관리 (ARC)</span>"
    ]
  },
  {
    "objectID": "ch11.html",
    "href": "ch11.html",
    "title": "11  다음 단계",
    "section": "",
    "text": "Apple의 Swift 문서: 공식 “The Swift Programming Language” 책은 훌륭하고 포괄적인 자료입니다.\nSwiftUI / UIKit: Apple 플랫폼용 사용자 인터페이스 구축.\n서버 사이드 Swift: Vapor 또는 Kitura와 같은 프레임워크.\n동시성: async/await, 액터.\n제네릭: 유연하고 재사용 가능한 함수 및 타입 작성.\n패키지 관리: Swift Package Manager (SPM).",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>다음 단계</span>"
    ]
  }
]