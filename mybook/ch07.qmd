# 함수

### 함수 정의 및 호출

**파이썬:**
```python
def greet(name):
    return f"Hello, {name}!"

message = greet("Alice")
print(message)
```

**Swift:**
```swift
func greet(name: String) -> String { // 매개변수 타입과 반환 타입이 명시적입니다
    return "Hello, \(name)!"
}

let message = greet(name: "Alice") // 호출 시 인자 레이블 'name'이 사용됩니다
print(message)
```
- Swift 함수는 `func` 키워드를 사용합니다.
- 매개변수 타입과 반환 타입은 **반드시** 지정해야 합니다.
- `->`는 반환 타입을 나타냅니다. 함수가 값을 반환하지 않으면 `-> Void`를 사용하거나 생략할 수 있습니다.

### 매개변수와 반환 값

**여러 매개변수:**
**파이썬:**
```python
def add(a, b):
    return a + b
```
**Swift:**
```swift
func add(a: Int, b: Int) -> Int {
    return a + b
}
let sum = add(a: 5, b: 3)
```

**매개변수 없음:**
**파이썬:**
```python
def say_hello():
    print("Hello!")
```
**Swift:**
```swift
func sayHello() { // 또는 func sayHello() -> Void {
    print("Hello!")
}
sayHello()
```

**튜플 반환 (여러 값 반환):**
**파이썬:**
```python
def get_coordinates():
    return 10, 20 # 튜플 반환

x, y = get_coordinates()
```
**Swift:**
```swift
func getCoordinates() -> (Int, Int) {
    return (10, 20)
}
let coordinates = getCoordinates()
print("x: \(coordinates.0), y: \(coordinates.1)")

func getNamedCoordinates() -> (x: Int, y: Int) {
    return (x: 10, y: 20)
}
let namedCoords = getNamedCoordinates()
print("x: \(namedCoords.x), y: \(namedCoords.y)")
```

### 인자 레이블과 매개변수 이름
기본적으로 Swift는 함수를 호출할 때 매개변수 이름을 인자 레이블로 사용합니다.

```swift
func someFunction(firstParameterName: Int, secondParameterName: Int) {
    // 함수 본문에서 firstParameterName은 첫 번째 매개변수 값을,
    // secondParameterName은 두 번째 매개변수 값을 참조합니다
}
// 호출 시 매개변수 이름을 레이블로 사용합니다:
// someFunction(firstParameterName: 1, secondParameterName: 2)
```

**다른 인자 레이블 지정:**
내부 매개변수 이름과 다른 외부 인자 레이블을 제공할 수 있습니다. 인자 레이블이 없도록 하려면 `_`를 사용합니다.

```swift
func greet(person name: String, from hometown: String) -> String {
    // 'name'과 'hometown'은 함수 내부에서 사용됩니다
    return "Hello \(name)! \(hometown)에서 오신 것을 환영합니다."
}
// 호출 방식:
print(greet(person: "Bill", from: "Cupertino"))
// 'person'과 'from'이 인자 레이블입니다.

func subtract(_ a: Int, by b: Int) -> Int { // 첫 번째 매개변수에 레이블 없음
    return a - b
}
let result = subtract(10, by: 3) // 호출: subtract(10, by: 3)
```
이는 레이블이 항상 매개변수 이름인 파이썬의 키워드 인자와 다릅니다.

**기본 매개변수 값:**
파이썬과 유사합니다.

**파이썬:**
```python
def power(base, exponent=2):
    return base ** exponent
```
**Swift:**
```swift
func power(base: Int, exponent: Int = 2) -> Int {
    var result = 1
    for _ in 0..<exponent {
        result *= base
    }
    return result
}
power(base: 3) // 9
power(base: 3, exponent: 3) // 27
```

**가변 매개변수 (파이썬의 `*args`와 유사):**
지정된 타입의 값을 0개 이상 받습니다.

**파이썬:**
```python
def average(*numbers):
    if not numbers:
        return 0
    return sum(numbers) / len(numbers)
```
**Swift:**
```swift
func average(_ numbers: Double...) -> Double { // numbers는 내부적으로 [Double]입니다
    if numbers.isEmpty {
        return 0.0
    }
    var total: Double = 0
    for number in numbers {
        total += number
    }
    return total / Double(numbers.count)
}
average(1.0, 2.0, 3.0) // 2.0
average()              // 0.0
```

**In-Out 매개변수 (참조에 의한 전달과 같이 매개변수를 직접 수정):**
함수 매개변수는 기본적으로 상수입니다. 함수가 매개변수 값을 수정하고 함수 호출이 끝난 후에도 해당 변경 사항이 유지되기를 원하면 해당 매개변수를 in-out 매개변수로 정의합니다.
in-out 매개변수에 인수를 전달할 때 변수 이름 바로 앞에 앰퍼샌드(`&`)를 붙입니다.

**파이썬 (객체는 참조로 전달되며, 가변 타입은 변경될 수 있음):**
```python
def modify_list(my_list):
    my_list.append(4)

items = [1, 2, 3]
modify_list(items) # items는 이제 [1, 2, 3, 4]입니다
```

**Swift:**
```swift
func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}

var someInt = 3
var anotherInt = 107
swapTwoInts(&someInt, &anotherInt) // &를 사용하여 참조로 전달
print("someInt는 이제 \(someInt)이고, anotherInt는 이제 \(anotherInt)입니다")
// "someInt는 이제 107이고, anotherInt는 이제 3입니다" 출력
```

### 일급 시민으로서의 함수
파이썬과 마찬가지로 Swift의 함수는 일급 타입입니다. 변수/상수에 할당하거나, 다른 함수에 인수로 전달하거나, 함수에서 반환할 수 있습니다.

**Swift:**
```swift
func addTwoInts(_ a: Int, _ b: Int) -> Int {
    return a + b
}

var mathFunction: (Int, Int) -> Int = addTwoInts // mathFunction은 (Int, Int) -> Int 타입입니다
print("결과: \(mathFunction(2, 3))") // 결과: 5

func printMathResult(_ mathFunc: (Int, Int) -> Int, _ a: Int, _ b: Int) {
    print("계산 결과: \(mathFunc(a, b))")
}
printMathResult(addTwoInts, 10, 5) // "계산 결과: 15"

func stepForward(_ input: Int) -> Int {
    return input + 1
}
func stepBackward(_ input: Int) -> Int {
    return input - 1
}

func chooseStepFunction(backward: Bool) -> (Int) -> Int { // 함수를 반환합니다
    return backward ? stepBackward : stepForward
}

var currentValue = 3
let moveNearerToZero = chooseStepFunction(backward: currentValue > 0)
// moveNearerToZero는 이제 stepBackward() 함수를 참조합니다
print("0으로 카운트:")
while currentValue != 0 {
    print("\(currentValue)... ")
    currentValue = moveNearerToZero(currentValue)
}
print("0!")
```

### 클로저
클로저는 코드 내에서 전달되고 사용될 수 있는 자체 포함된 기능 블록입니다. 파이썬의 `lambda` 함수와 유사하지만 훨씬 더 강력하고 다재다능하며, Ruby의 블록이나 JavaScript의 익명 함수와 비슷합니다.

**파이썬 Lambda:**
```python
numbers = [1, 2, 3, 4]
squared = list(map(lambda x: x * x, numbers)) # [1, 4, 9, 16]
```

**Swift 클로저:**
클로저는 정의된 컨텍스트의 모든 상수와 변수에 대한 참조를 캡처하고 저장할 수 있습니다 (이를 "클로징 오버"라고 함).

일반적인 형태:
```swift
{ (매개변수) -> 반환_타입 in
    // 문장들
}
```

`sorted(by:)` 메서드 예시:
```swift
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]

// 정렬을 위해 정의된 함수 사용
func backward(_ s1: String, _ s2: String) -> Bool {
    return s1 > s2
}
var reversedNames = names.sorted(by: backward) // ["Ewa", "Daniella", "Chris", "Barry", "Alex"]

// 클로저 표현식 사용
reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in
    return s1 > s2
})

// 컨텍스트에서 타입 추론 (Swift는 매개변수 및 반환 값의 타입을 추론할 수 있음)
reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 })

// 단일 표현식 클로저의 암시적 반환
reversedNames = names.sorted(by: { s1, s2 in s1 > s2 })

// 축약형 인자 이름 ($0, $1, $2 등)
reversedNames = names.sorted(by: { $0 > $1 })

// 연산자 메서드 (연산자 함수가 필요한 타입과 일치하는 경우)
reversedNames = names.sorted(by: >) // 이 경우 가장 간단한 형태
```

**후행 클로저:**
클로저 표현식이 함수의 마지막 인수인 경우, 함수 호출 괄호 뒤에 *후행 클로저*로 작성할 수 있습니다. 클로저가 *유일한* 인수인 경우 괄호를 완전히 생략할 수 있습니다.

```swift
// func someFunctionThatTakesAClosure(closure: () -> Void) { /* ... */ }

// 후행 클로저로 호출:
// someFunctionThatTakesAClosure() {
//     // 클로저 본문이 여기에 들어갑니다
// }
// 또는
// someFunctionThatTakesAClosure {
//     // 클로저 본문
// }

let numbers = [1, 2, 3, 4]
let squaredNumbers = numbers.map { number in // 후행 클로저
    number * number
}
print(squaredNumbers) // [1, 4, 9, 16]

let mappedNumbers = numbers.map { number -> String in // 명시적 반환 타입을 가진 후행 클로저
    return "숫자: \(number)"
}
print(mappedNumbers) // ["숫자: 1", "숫자: 2", "숫자: 3", "숫자: 4"]
```

클로저는 Swift에서 광범위하게 사용되며, 특히 콜백, 비동기 작업 및 함수형 프로그래밍 패턴에 유용합니다.
