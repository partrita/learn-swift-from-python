# 메모리 관리 (ARC)

Swift는 클래스 인스턴스의 메모리를 관리하기 위해 자동 참조 계산(ARC)을 사용합니다. ARC는 해당 인스턴스가 더 이상 필요하지 않을 때 클래스 인스턴스에서 사용한 메모리를 자동으로 해제합니다.
- 일반적으로 메모리 관리에 대해 직접 생각할 필요가 없습니다.
- ARC는 각 클래스 인스턴스를 현재 참조하고 있는 프로퍼티, 상수 및 변수가 몇 개인지 추적하여 작동합니다. 해당 인스턴스에 대한 활성 참조가 하나 이상 존재하는 한 인스턴스를 할당 해제하지 않습니다.
- **강한 참조 순환:** ARC는 때때로 두 클래스 인스턴스가 서로 강한 참조를 유지하여 절대 할당 해제되지 않는 상황(메모리 누수)을 유발할 수 있습니다. Swift는 이러한 순환을 해결하기 위해 `weak` 및 `unowned` 참조를 제공합니다.
    - **`weak` 참조:** 약한 참조는 참조하는 인스턴스에 대한 강한 유지를 하지 않으므로 ARC가 참조된 인스턴스를 할당 해제하는 것을 막지 않습니다. 인스턴스가 할당 해제되면 참조는 `nil`이 됩니다. 따라서 약한 참조는 옵셔널 타입이어야 합니다.
    - **`unowned` 참조:** 약한 참조와 마찬가지로 미소유 참조는 강한 유지를 하지 않습니다. 그러나 미소유 참조는 다른 인스턴스가 동일한 수명 또는 더 긴 수명을 가질 때 사용됩니다. 항상 값을 가질 것으로 가정됩니다. 인스턴스가 할당 해제된 후 미소유 참조에 접근하면 런타임 오류가 발생합니다.

**파이썬 (가비지 컬렉션):**
파이썬은 참조 계산과 순환 가비지 컬렉터의 조합을 사용하여 메모리를 관리합니다. 일반적으로 메모리를 수동으로 관리하지 않습니다.

**Swift (ARC 예제 - 강한 참조 순환):**
```swift
class PersonARC {
    let name: String
    init(name: String) { self.name = name }
    var apartment: ApartmentARC? // 옵셔널, nil일 수 있음
    deinit { print("\(name)이(가) 소멸화 중입니다 (Person)") }
}

class ApartmentARC {
    let unit: String
    init(unit: String) { self.unit = unit }
    // weak var tenant: PersonARC? // 순환을 끊으려면 weak 사용
    var tenant: PersonARC? // 기본적으로 강한 참조
    deinit { print("아파트 \(unit)이(가) 소멸화 중입니다") }
}

var johnArc: PersonARC?
var unit4A: ApartmentARC?

johnArc = PersonARC(name: "John Appleseed")
unit4A = ApartmentARC(unit: "4A")

// 강한 참조 순환 생성:
johnArc!.apartment = unit4A
unit4A!.tenant = johnArc // tenant가 weak가 아니면 순환이 생성됨

// 둘 다 nil로 설정합니다. 순환이 있으면 deinit이 호출되지 않습니다.
johnArc = nil
unit4A = nil
// ApartmentARC의 'tenant'가 'var tenant: PersonARC?'이면 deinit 메시지가 출력되지 않습니다.
// ApartmentARC의 'tenant'가 'weak var tenant: PersonARC?'이면 deinit 메시지가 출력됩니다.
```
위의 순환을 끊으려면 `ApartmentARC`의 `tenant`를 `weak var tenant: PersonARC?`로 선언해야 합니다.
